package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Administrateur;
import com.scheduling.universityschedule_backend.model.Notification;
import com.scheduling.universityschedule_backend.model.PropositionDeRattrapage;
import com.scheduling.universityschedule_backend.repository.AdministrateurRepository;
import com.scheduling.universityschedule_backend.repository.FichierExcelRepository;
import com.scheduling.universityschedule_backend.repository.NotificationRepository;
import com.scheduling.universityschedule_backend.repository.PropositionDeRattrapageRepository;
import com.scheduling.universityschedule_backend.service.AdministrateurService;
import com.scheduling.universityschedule_backend.service.NotificationService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service implementation for administrator operations.
 * Contains business logic for schedule management, makeup sessions,
 * and system-wide notifications.
 */
@Service
@Transactional
public class AdministrateurServiceImpl implements AdministrateurService {

    private final AdministrateurRepository administrateurRepository;
    private final FichierExcelRepository fichierExcelRepository;
    private final PropositionDeRattrapageRepository propositionRepository;
    private final NotificationRepository notificationRepository;
    private final NotificationService notificationService;
    private final EntityMapper mapper;

    public AdministrateurServiceImpl(AdministrateurRepository administrateurRepository,
                                     FichierExcelRepository fichierExcelRepository,
                                     PropositionDeRattrapageRepository propositionRepository,
                                     NotificationRepository notificationRepository,
                                     NotificationService notificationService,
                                     EntityMapper mapper) {
        this.administrateurRepository = administrateurRepository;
        this.fichierExcelRepository = fichierExcelRepository;
        this.propositionRepository = propositionRepository;
        this.notificationRepository = notificationRepository;
        this.notificationService = notificationService;
        this.mapper = mapper;
    }

    @Override
    public AdministrateurDTO findById(Long id) throws CustomException {
        Optional<Administrateur> adminOpt = administrateurRepository.findById(id);
        if (adminOpt.isEmpty()) {
            throw new CustomException("Administrateur not found with id " + id);
        }
        return mapper.toAdministrateurDTO(adminOpt.get());
    }

    @Override
    public void importExcelSchedule(FichierExcelDTO fichier) throws CustomException {
        // Convert DTO to entity and simulate file import processing
        try {
            // For simulation purposes, we set the status and current import date.
            fichier.setStatus("Processing");
            fichier.setImportDate(LocalDateTime.now());
            // Save the import record (simulate import)
            fichierExcelRepository.save(mapper.toFichierExcel(fichier));
            // Assume after processing, status becomes "Successful"
            fichier.setStatus("Successful");
        } catch (Exception e) {
            throw new CustomException("Failed to import Excel schedule: " + e.getMessage());
        }
    }

    @Override
    public void generateSchedule() throws CustomException {
        // Simulate schedule generation based on constraints.
        // In a real system, this method would contain the scheduling algorithm.
        try {
            // For example, iterate over sessions and assign available rooms and teachers.
            // After generating, notify all affected users.
            // This is just a simulation.
            Notification notification = new Notification();
            notification.setMessage("New schedule has been generated.");
            notification.setDate(LocalDateTime.now());
            notification.setType("update");
            notification.setRead(false);
            // Save notification so that NotificationService can broadcast it
            notificationRepository.save(notification);
        } catch (Exception e) {
            throw new CustomException("Failed to generate schedule: " + e.getMessage());
        }
    }

    @Override
    public List<PropositionDeRattrapageDTO> getAllMakeupSessions() throws CustomException {
        try {
            return propositionRepository.findAll()
                    .stream()
                    .map(mapper::toPropositionDeRattrapageDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve makeup sessions: " + e.getMessage());
        }
    }

    @Override
    public void approveMakeupSession(Long id) throws CustomException {
        PropositionDeRattrapage proposition = propositionRepository.findById(id)
                .orElseThrow(() -> new CustomException("Makeup session not found with id " + id));
        proposition.setStatus("approved");
        propositionRepository.save(proposition);
        // Notify the teacher that his/her proposal was approved.
        Notification notification = new Notification();
        notification.setMessage("Your makeup session proposal (ID " + id + ") has been approved.");
        notification.setDate(LocalDateTime.now());
        notification.setType("alert");
        notification.setRead(false);
        if (proposition.getEnseignant() != null) {
            notification.setRecepteur(proposition.getEnseignant());
        }
        notificationRepository.save(notification);
        notificationService.broadcastNotification(mapper.toNotificationDTO(notification));
    }

    @Override
    public void rejectMakeupSession(Long id) throws CustomException {
        PropositionDeRattrapage proposition = propositionRepository.findById(id)
                .orElseThrow(() -> new CustomException("Makeup session not found with id " + id));
        proposition.setStatus("rejected");
        propositionRepository.save(proposition);
        // Notify the teacher that his/her proposal was rejected.
        Notification notification = new Notification();
        notification.setMessage("Your makeup session proposal (ID " + id + ") has been rejected.");
        notification.setDate(LocalDateTime.now());
        notification.setType("alert");
        notification.setRead(false);
        if (proposition.getEnseignant() != null) {
            notification.setRecepteur(proposition.getEnseignant());
        }
        notificationRepository.save(notification);
        notificationService.broadcastNotification(mapper.toNotificationDTO(notification));
    }

    @Override
    public void broadcastNotification(NotificationDTO notificationDTO) throws CustomException {
        try {
            // For demonstration, broadcast means saving a notification record.
            Notification notification = mapper.toNotification(notificationDTO);
            notification.setDate(LocalDateTime.now());
            notification.setRead(false);
            notificationRepository.save(notification);
        } catch (Exception e) {
            throw new CustomException("Failed to broadcast notification: " + e.getMessage());
        }
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.BrancheDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Branche;
import com.scheduling.universityschedule_backend.repository.BrancheRepository;
import com.scheduling.universityschedule_backend.service.BrancheService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service implementation for branch management.
 * Handles CRUD operations for academic branches.
 */
@Service
@Transactional
public class BrancheServiceImpl implements BrancheService {

    private final BrancheRepository brancheRepository;
    private final EntityMapper mapper;

    public BrancheServiceImpl(BrancheRepository brancheRepository, EntityMapper mapper) {
        this.brancheRepository = brancheRepository;
        this.mapper = mapper;
    }

    @Override
    public List<BrancheDTO> findAll() throws CustomException {
        try {
            return brancheRepository.findAll()
                    .stream()
                    .map(mapper::toBrancheDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve branches: " + e.getMessage());
        }
    }

    @Override
    public BrancheDTO findById(Long id) throws CustomException {
        Optional<Branche> brancheOpt = brancheRepository.findById(id);
        if (brancheOpt.isEmpty()) {
            throw new CustomException("Branche not found with id " + id);
        }
        return mapper.toBrancheDTO(brancheOpt.get());
    }

    @Override
    public BrancheDTO create(BrancheDTO brancheDTO) throws CustomException {
        try {
            Branche branche = mapper.toBranche(brancheDTO);
            branche = brancheRepository.save(branche);
            return mapper.toBrancheDTO(branche);
        } catch (Exception e) {
            throw new CustomException("Failed to create branch: " + e.getMessage());
        }
    }

    @Override
    public BrancheDTO update(Long id, BrancheDTO brancheDTO) throws CustomException {
        Branche existing = brancheRepository.findById(id)
                .orElseThrow(() -> new CustomException("Branche not found with id " + id));
        existing.setNiveau(brancheDTO.getNiveau());
        existing.setSpecialite(brancheDTO.getSpecialite());
        existing.setNbTD(brancheDTO.getNbTD());
        existing.setDepartement(brancheDTO.getDepartement());
        brancheRepository.save(existing);
        return mapper.toBrancheDTO(existing);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!brancheRepository.existsById(id)) {
            throw new CustomException("Branche not found with id " + id);
        }
        brancheRepository.deleteById(id);
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.EnseignantDTO;
import com.scheduling.universityschedule_backend.dto.PropositionDeRattrapageDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.SignalDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Enseignant;
import com.scheduling.universityschedule_backend.model.PropositionDeRattrapage;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.model.Signal;
import com.scheduling.universityschedule_backend.repository.EnseignantRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.repository.SignalRepository;
import com.scheduling.universityschedule_backend.repository.PropositionDeRattrapageRepository;
import com.scheduling.universityschedule_backend.service.EnseignantService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service implementation for teacher operations.
 * Manages teacher schedules, teaching hours, makeup requests, and signals.
 */
@Service
@Transactional
public class EnseignantServiceImpl implements EnseignantService {

    private final EnseignantRepository enseignantRepository;
    private final SeanceRepository seanceRepository;
    private final SignalRepository signalRepository;
    private final PropositionDeRattrapageRepository propositionRepository;
    private final EntityMapper mapper;

    public EnseignantServiceImpl(EnseignantRepository enseignantRepository,
                                 SeanceRepository seanceRepository,
                                 SignalRepository signalRepository,
                                 PropositionDeRattrapageRepository propositionRepository,
                                 EntityMapper mapper) {
        this.enseignantRepository = enseignantRepository;
        this.seanceRepository = seanceRepository;
        this.signalRepository = signalRepository;
        this.propositionRepository = propositionRepository;
        this.mapper = mapper;
    }

    @Override
    public EnseignantDTO findById(Long id) throws CustomException {
        Optional<Enseignant> enseignantOpt = enseignantRepository.findById(id);
        if (enseignantOpt.isEmpty()) {
            throw new CustomException("Enseignant not found with id " + id);
        }
        return mapper.toEnseignantDTO(enseignantOpt.get());
    }

    @Override
    public List<SeanceDTO> getSchedule(Long id) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Enseignant not found with id " + id));
        List<Seance> sessions = enseignant.getSeances();
        return sessions.stream().map(mapper::toSeanceDTO).collect(Collectors.toList());
    }

    @Override
    public int getTotalTeachingHours(Long id) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Enseignant not found with id " + id));
        return enseignant.getHeures();
    }

    @Override
    public PropositionDeRattrapageDTO submitMakeupRequest(Long id, PropositionDeRattrapageDTO propositionDTO) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Enseignant not found with id " + id));
        PropositionDeRattrapage proposition = mapper.toPropositionDeRattrapage(propositionDTO);
        proposition.setEnseignant(enseignant);
        proposition.setStatus("pending");
        proposition = propositionRepository.save(proposition);
        return mapper.toPropositionDeRattrapageDTO(proposition);
    }

    @Override
    public SignalDTO submitSignal(Long id, SignalDTO signalDTO) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Enseignant not found with id " + id));
        Signal signal = mapper.toSignal(signalDTO);
        signal = signalRepository.save(signal);
        return mapper.toSignalDTO(signal);
    }

    @Override
    public List<SignalDTO> getSignals(Long id) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Enseignant not found with id " + id));
        // In a real application, filter signals by teacher.
        List<Signal> allSignals = signalRepository.findAll();
        return allSignals.stream()
                .filter(signal -> signal.getId() != null) // Replace with actual teacher filter if available.
                .map(mapper::toSignalDTO)
                .collect(Collectors.toList());
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.NotificationDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.model.Notification;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.repository.EtudiantRepository;
import com.scheduling.universityschedule_backend.repository.NotificationRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.EtudiantService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service implementation for student operations.
 * Manages student schedules and notifications.
 */
@Service
@Transactional
public class EtudiantServiceImpl implements EtudiantService {

    private final EtudiantRepository etudiantRepository;
    private final SeanceRepository seanceRepository;
    private final NotificationRepository notificationRepository;
    private final EntityMapper mapper;

    public EtudiantServiceImpl(EtudiantRepository etudiantRepository,
                               SeanceRepository seanceRepository,
                               NotificationRepository notificationRepository,
                               EntityMapper mapper) {
        this.etudiantRepository = etudiantRepository;
        this.seanceRepository = seanceRepository;
        this.notificationRepository = notificationRepository;
        this.mapper = mapper;
    }

    @Override
    public EtudiantDTO findById(Long id) throws CustomException {
        Optional<Etudiant> etudiantOpt = etudiantRepository.findById(id);
        if (etudiantOpt.isEmpty()) {
            throw new CustomException("Etudiant not found with id " + id);
        }
        return mapper.toEtudiantDTO(etudiantOpt.get());
    }

    @Override
    public List<SeanceDTO> getPersonalSchedule(Long id) throws CustomException {
        Etudiant etudiant = etudiantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Etudiant not found with id " + id));
        if (etudiant.getTp() == null) {
            throw new CustomException("No practical session associated for student id " + id);
        }
        List<Seance> sessions = etudiant.getTp().getSeances();
        return sessions.stream().map(mapper::toSeanceDTO).collect(Collectors.toList());
    }

    @Override
    public List<SeanceDTO> getBranchSchedule(Long brancheId) throws CustomException {
        List<Seance> sessions = seanceRepository.findAll();
        List<Seance> filtered = sessions.stream()
                .filter(seance -> seance.getBranches() != null &&
                        seance.getBranches().stream().anyMatch(branche -> branche.getId().equals(brancheId)))
                .toList();
        return filtered.stream().map(mapper::toSeanceDTO).collect(Collectors.toList());
    }

    @Override
    public List<NotificationDTO> getNotifications(Long id) throws CustomException {
        List<Notification> notifications = notificationRepository.findAll()
                .stream()
                .filter(n -> n.getRecepteur() != null && n.getRecepteur().getId().equals(id))
                .toList();
        return notifications.stream().map(mapper::toNotificationDTO).collect(Collectors.toList());
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.FichierExcelDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.FichierExcel;
import com.scheduling.universityschedule_backend.repository.FichierExcelRepository;
import com.scheduling.universityschedule_backend.service.ExcelFileService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service implementation for Excel file management.
 * Handles upload and tracking of Excel schedule imports.
 */
@Service
@Transactional
public class ExcelFileServiceImpl implements ExcelFileService {

    private final FichierExcelRepository fichierExcelRepository;
    private final EntityMapper mapper;

    public ExcelFileServiceImpl(FichierExcelRepository fichierExcelRepository, EntityMapper mapper) {
        this.fichierExcelRepository = fichierExcelRepository;
        this.mapper = mapper;
    }

    @Override
    public void upload(FichierExcelDTO file) throws CustomException {
        try {
            FichierExcel fichier = mapper.toFichierExcel(file);
            fichier.setImportDate(java.time.LocalDateTime.now());
            fichier.setStatus("Processing");
            fichierExcelRepository.save(fichier);
            fichier.setStatus("Successful");
            fichierExcelRepository.save(fichier);
        } catch (Exception e) {
            throw new CustomException("Excel file upload failed: " + e.getMessage());
        }
    }

    @Override
    public List<FichierExcelDTO> getImportHistory() throws CustomException {
        try {
            return fichierExcelRepository.findAll()
                    .stream()
                    .map(mapper::toFichierExcelDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve import history: " + e.getMessage());
        }
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.NotificationDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Notification;
import com.scheduling.universityschedule_backend.repository.NotificationRepository;
import com.scheduling.universityschedule_backend.service.NotificationService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service implementation for notification management.
 * Handles system notifications and user alerts.
 */
@Service
@Transactional
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;
    private final EntityMapper mapper;

    public NotificationServiceImpl(NotificationRepository notificationRepository, EntityMapper mapper) {
        this.notificationRepository = notificationRepository;
        this.mapper = mapper;
    }

    @Override
    public List<NotificationDTO> findAll() throws CustomException {
        try {
            return notificationRepository.findAll()
                    .stream()
                    .map(mapper::toNotificationDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve notifications: " + e.getMessage());
        }
    }

    @Override
    public void markAsRead(Long id) throws CustomException {
        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new CustomException("Notification not found with id " + id));
        notification.setRead(true);
        notificationRepository.save(notification);
    }

    @Override
    public List<NotificationDTO> getUnreadNotifications() throws CustomException {
        try {
            return notificationRepository.findAll()
                    .stream()
                    .filter(notification -> notification.getRead() != null && !notification.getRead())
                    .map(mapper::toNotificationDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve unread notifications: " + e.getMessage());
        }
    }

    @Override
    public void broadcastNotification(NotificationDTO notificationDTO) throws CustomException {
        try {
            Notification notification = mapper.toNotification(notificationDTO);
            notification.setDate(java.time.LocalDateTime.now());
            notification.setRead(false);
            notificationRepository.save(notification);
        } catch (Exception e) {
            throw new CustomException("Broadcast failed: " + e.getMessage());
        }
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SalleDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Salle;
import com.scheduling.universityschedule_backend.repository.SalleRepository;
import com.scheduling.universityschedule_backend.service.SalleService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service implementation for room management.
 * Handles CRUD operations and room availability.
 */
@Service
@Transactional
public class SalleServiceImpl implements SalleService {

    private final SalleRepository salleRepository;
    private final EntityMapper mapper;

    public SalleServiceImpl(SalleRepository salleRepository, EntityMapper mapper) {
        this.salleRepository = salleRepository;
        this.mapper = mapper;
    }

    @Override
    public List<SalleDTO> findAll() throws CustomException {
        try {
            return salleRepository.findAll()
                    .stream()
                    .map(mapper::toSalleDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve rooms: " + e.getMessage());
        }
    }

    @Override
    public SalleDTO findById(Long id) throws CustomException {
        Optional<Salle> salleOpt = salleRepository.findById(id);
        if (salleOpt.isEmpty()) {
            throw new CustomException("Room not found with id " + id);
        }
        return mapper.toSalleDTO(salleOpt.get());
    }

    @Override
    public SalleDTO create(SalleDTO salleDTO) throws CustomException {
        try {
            Salle salle = mapper.toSalle(salleDTO);
            salle = salleRepository.save(salle);
            return mapper.toSalleDTO(salle);
        } catch (Exception e) {
            throw new CustomException("Failed to create room: " + e.getMessage());
        }
    }

    @Override
    public SalleDTO update(Long id, SalleDTO salleDTO) throws CustomException {
        Salle existing = salleRepository.findById(id)
                .orElseThrow(() -> new CustomException("Room not found with id " + id));
        existing.setIdentifiant(salleDTO.getIdentifiant());
        existing.setType(salleDTO.getType());
        existing.setCapacite(salleDTO.getCapacite());
        existing.setDisponibilite(salleDTO.getDisponibilite());
        salleRepository.save(existing);
        return mapper.toSalleDTO(existing);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!salleRepository.existsById(id)) {
            throw new CustomException("Room not found with id " + id);
        }
        salleRepository.deleteById(id);
    }

    @Override
    public List<SalleDTO> getAvailableRooms(String date, String startTime, String endTime) throws CustomException {
        try {
            return salleRepository.findAll().stream()
                    .filter(salle -> salle.getDisponibilite() != null &&
                            salle.getDisponibilite().stream().anyMatch(slot -> slot.contains(date) &&
                                    slot.contains(startTime) && slot.contains(endTime)))
                    .map(mapper::toSalleDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to search available rooms: " + e.getMessage());
        }
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceConflictDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.SeanceService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service implementation for session management.
 * Handles CRUD operations and conflict detection.
 */
@Service
@Transactional
public class SeanceServiceImpl implements SeanceService {

    private final SeanceRepository seanceRepository;
    private final EntityMapper mapper;

    public SeanceServiceImpl(SeanceRepository seanceRepository, EntityMapper mapper) {
        this.seanceRepository = seanceRepository;
        this.mapper = mapper;
    }

    @Override
    public List<SeanceDTO> findAll() throws CustomException {
        try {
            return seanceRepository.findAll()
                    .stream()
                    .map(mapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve sessions: " + e.getMessage());
        }
    }

    @Override
    public SeanceDTO findById(Long id) throws CustomException {
        Optional<Seance> seanceOpt = seanceRepository.findById(id);
        if (seanceOpt.isEmpty()) {
            throw new CustomException("Session not found with id " + id);
        }
        return mapper.toSeanceDTO(seanceOpt.get());
    }

    @Override
    public SeanceDTO create(SeanceDTO seanceDTO) throws CustomException {
        try {
            Seance seance = mapper.toSeance(seanceDTO);
            seance = seanceRepository.save(seance);
            return mapper.toSeanceDTO(seance);
        } catch (Exception e) {
            throw new CustomException("Failed to create session: " + e.getMessage());
        }
    }

    @Override
    public SeanceDTO update(Long id, SeanceDTO seanceDTO) throws CustomException {
        Seance existing = seanceRepository.findById(id)
                .orElseThrow(() -> new CustomException("Session not found with id " + id));
        existing.setJour(seanceDTO.getJour());
        existing.setHeureDebut(seanceDTO.getHeureDebut());
        existing.setHeureFin(seanceDTO.getHeureFin());
        existing.setType(seanceDTO.getType());
        existing.setMatiere(seanceDTO.getMatiere());
        existing.setFrequence(seanceDTO.getFrequence());
        seanceRepository.save(existing);
        return mapper.toSeanceDTO(existing);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!seanceRepository.existsById(id)) {
            throw new CustomException("Session not found with id " + id);
        }
        seanceRepository.deleteById(id);
    }

    @Override
    public List<SeanceConflictDTO> getAllConflicts() throws CustomException {
        try {
            List<Object[]> conflictPairs = seanceRepository.findConflictingSeancePairs();
            List<SeanceConflictDTO> conflicts = new ArrayList<>();
            for (Object[] pair : conflictPairs) {
                Seance s1 = (Seance) pair[0];
                Seance s2 = (Seance) pair[1];
                SeanceConflictDTO conflict = new SeanceConflictDTO(s1.getId(), s2.getId(), List.of("general"));
                conflicts.add(conflict);
            }
            return conflicts;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve conflicts: " + e.getMessage());
        }
    }

    @Override
    public List<SeanceConflictDTO> getRoomConflicts() throws CustomException {
        try {
            List<Object[]> conflictPairs = seanceRepository.findConflictingByRooms();
            List<SeanceConflictDTO> conflicts = new ArrayList<>();
            for (Object[] pair : conflictPairs) {
                Seance s1 = (Seance) pair[0];
                Seance s2 = (Seance) pair[1];
                SeanceConflictDTO conflict = new SeanceConflictDTO(s1.getId(), s2.getId(), List.of("room"));
                conflicts.add(conflict);
            }
            return conflicts;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve room conflicts: " + e.getMessage());
        }
    }

    @Override
    public List<SeanceConflictDTO> getConflictsForSession(Long seanceId) throws CustomException {
        try {
            Seance target = seanceRepository.findById(seanceId)
                    .orElseThrow(() -> new CustomException("Session not found with id " + seanceId));
            List<Seance> conflicts = seanceRepository.findRoomConflictsForSeance(
                    seanceId, target.getJour(), 
                    target.getSalle() != null ? target.getSalle().getId() : null,
                    target.getHeureDebut(), target.getHeureFin());
            return conflicts.stream()
                    .map(s -> new SeanceConflictDTO(seanceId, s.getId(), List.of("room")))
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve conflicts for session: " + e.getMessage());
        }
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.TDDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.TD;
import com.scheduling.universityschedule_backend.model.TP;
import com.scheduling.universityschedule_backend.repository.TDRepository;
import com.scheduling.universityschedule_backend.repository.TPRepository;
import com.scheduling.universityschedule_backend.service.TDService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service implementation for tutorial group management.
 * Handles operations related to tutorial sessions.
 */
@Service
@Transactional
public class TDServiceImpl implements TDService {

    private final TDRepository tdRepository;
    private final TPRepository tpRepository;
    private final EntityMapper mapper;

    public TDServiceImpl(TDRepository tdRepository, TPRepository tpRepository, EntityMapper mapper) {
        this.tdRepository = tdRepository;
        this.tpRepository = tpRepository;
        this.mapper = mapper;
    }

    @Override
    public List<TDDTO> findAll() throws CustomException {
        try {
            return tdRepository.findAll().stream().map(mapper::toTDDTO).collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve tutorial groups: " + e.getMessage());
        }
    }

    @Override
    public TDDTO findById(Long id) throws CustomException {
        Optional<TD> tdOpt = tdRepository.findById(id);
        if (tdOpt.isEmpty()) {
            throw new CustomException("Tutorial group not found with id " + id);
        }
        return mapper.toTDDTO(tdOpt.get());
    }

    @Override
    public List<TPDTO> getTPs(Long tdId) throws CustomException {
        TD td = tdRepository.findById(tdId)
                .orElseThrow(() -> new CustomException("Tutorial group not found with id " + tdId));
        List<TP> tps = td.getTpList();
        return tps.stream().map(mapper::toTPDTO).collect(Collectors.toList());
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.TP;
import com.scheduling.universityschedule_backend.repository.TPRepository;
import com.scheduling.universityschedule_backend.service.TPService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service implementation for practical session management.
 * Handles operations related to lab sessions.
 */
@Service
@Transactional
public class TPServiceImpl implements TPService {

    private final TPRepository tpRepository;
    private final EntityMapper mapper;

    public TPServiceImpl(TPRepository tpRepository, EntityMapper mapper) {
        this.tpRepository = tpRepository;
        this.mapper = mapper;
    }

    @Override
    public List<TPDTO> findAll() throws CustomException {
        try {
            return tpRepository.findAll().stream().map(mapper::toTPDTO).collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve practical sessions: " + e.getMessage());
        }
    }

    @Override
    public TPDTO findById(Long id) throws CustomException {
        Optional<TP> tpOpt = tpRepository.findById(id);
        if (tpOpt.isEmpty()) {
            throw new CustomException("Practical session not found with id " + id);
        }
        return mapper.toTPDTO(tpOpt.get());
    }

    @Override
    public List<EtudiantDTO> getStudents(Long tpId) throws CustomException {
        TP tp = tpRepository.findById(tpId)
                .orElseThrow(() -> new CustomException("Practical session not found with id " + tpId));
        return tp.getEtudiants().stream()
                .map(mapper::toEtudiantDTO)
                .collect(Collectors.toList());
    }
}
