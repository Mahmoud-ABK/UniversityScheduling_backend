package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import java.util.List;

/**
 * Service interface for administrator operations.
 * Handles schedule management, makeup sessions, and system-wide notifications.
 */
public interface AdministrateurService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves administrator details by ID.
     * @param id Administrator's unique identifier
     * @return Administrator DTO
     * @throws CustomException if administrator not found
     */
    AdministrateurDTO findById(Long id) throws CustomException;

    /**
     * Retrieves all administrators.
     * @return List of all administrators
     * @throws CustomException if retrieval fails
     */
    List<AdministrateurDTO> findAll() throws CustomException;

    /**
     * Creates a new administrator.
     * @param administrateur Administrator DTO containing the new data
     * @return Created administrator DTO
     * @throws CustomException if creation fails
     */
    AdministrateurDTO create(AdministrateurDTO administrateur) throws CustomException;

    /**
     * Updates an existing administrator.
     * @param id Administrator's unique identifier
     * @param administrateur Updated administrator data
     * @return Updated administrator DTO
     * @throws CustomException if update fails
     */
    AdministrateurDTO update(Long id, AdministrateurDTO administrateur) throws CustomException;

    /**
     * Deletes an administrator by ID.
     * @param id Administrator's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================



    /**
     * Retrieves all makeup session requests.
     * @return List of makeup session proposals
     * @throws CustomException if retrieval fails
     */
    List<PropositionDeRattrapageDTO> getAllMakeupSessions() throws CustomException;

    /**
     * Processes initial makeup session requests (Admin only).
     * Status Flow: PENDING -> SCHEDULED or APPROVED
     *
     * @param id      Proposal ID
     * @param salleId Optional room ID. If null, sets status to SCHEDULED
     * @return Updated proposal
     * @throws CustomException if proposal isn't PENDING or other errors occur
     */
    PropositionDeRattrapageDTO approveMakeupSession(Long id, Long salleId) throws CustomException;

    /**
     * Rejects a PENDING makeup session proposal (Admin only).
     * Status Flow: PENDING -> REJECTED
     *
     * @param id Proposal ID
     * @return Updated proposal
     * @throws CustomException if proposal isn't PENDING or other errors occur
     */
    PropositionDeRattrapageDTO rejectMakeupSession(Long id) throws CustomException;

    /**
     * Approves a SCHEDULED makeup session (Technician/Admin).
     * Status Flow: SCHEDULED -> APPROVED
     *
     * @param id      Proposal ID
     * @param salleId Room ID (required)
     * @return Updated proposal with created Seance
     * @throws CustomException if proposal isn't SCHEDULED or other errors occur
     */
    PropositionDeRattrapageDTO approveScheduled(Long id, Long salleId) throws CustomException;

    /**
     * Rejects a SCHEDULED makeup session (Technician/Admin).
     * Status Flow: SCHEDULED -> REJECTED
     *
     * @param id     Proposal ID
     * @param reason Rejection reason
     * @return Updated proposal
     * @throws CustomException if proposal isn't SCHEDULED or other errors occur
     */
    PropositionDeRattrapageDTO rejectScheduled(Long id, String reason) throws CustomException;


}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.authdtos.*;
import com.scheduling.universityschedule_backend.model.AuditLog;
import com.scheduling.universityschedule_backend.model.UserCredentials;
import com.scheduling.universityschedule_backend.model.enums.AuditAction;
import com.scheduling.universityschedule_backend.model.enums.UserStatus;
import com.scheduling.universityschedule_backend.repository.AuditLogRepository;
import com.scheduling.universityschedule_backend.repository.UserCredentialsRepository;
import com.scheduling.universityschedule_backend.security.JwtUtil;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

@Service
public class AuthenticationService {

    private final AuthenticationManager authenticationManager;
    private final UserCredentialsRepository userCredentialsRepository;
    private final AuditLogRepository auditLogRepository;
    private final JwtUtil jwtUtil;
    private final PasswordEncoder passwordEncoder;

    public AuthenticationService(
            AuthenticationManager authenticationManager,
            UserCredentialsRepository userCredentialsRepository,
            AuditLogRepository auditLogRepository,
            JwtUtil jwtUtil,
            PasswordEncoder passwordEncoder) {
        this.authenticationManager = authenticationManager;
        this.userCredentialsRepository = userCredentialsRepository;
        this.auditLogRepository = auditLogRepository;
        this.jwtUtil = jwtUtil;
        this.passwordEncoder = passwordEncoder;
    }

    @Transactional
    public LoginResponseDTO login(LoginRequestDTO loginRequest) {
        UserCredentials credentials = userCredentialsRepository.findByUsername(loginRequest.getUsername())
                .orElseThrow(() -> new BadCredentialsException("Invalid username or password"));

        if (credentials.getStatus() == UserStatus.LOCKED) {
            if (credentials.getLockTime().plusMinutes(15).isAfter(LocalDateTime.now())) {
                auditLogRepository.save(AuditLog.builder()
                        .userLogin(loginRequest.getUsername())
                        .action(AuditAction.LOGIN_FAILED.name())
                        .details("Account locked")
                        .timestamp(LocalDateTime.now())
                        .build());
                throw new BadCredentialsException("Account is locked. Try again later.");
            } else {
                credentials.setStatus(UserStatus.ACTIVE);
                credentials.setFailedAttempts(0);
                credentials.setLockTime(null);
                userCredentialsRepository.save(credentials);
            }
        }

        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(),
                            loginRequest.getPassword()
                    )
            );

            credentials.setFailedAttempts(0);
            userCredentialsRepository.save(credentials);

            String accessToken = jwtUtil.generateAccessToken(
                    credentials.getUsername(),
                    credentials.getRole().getAuthority()
            );
            String refreshToken = jwtUtil.generateRefreshToken(credentials.getUsername());

            auditLogRepository.save(AuditLog.builder()
                    .userLogin(loginRequest.getUsername())
                    .action(AuditAction.LOGIN_SUCCESS.name())
                    .timestamp(LocalDateTime.now())
                    .build());

            LoginResponseDTO response = new LoginResponseDTO();
            response.setAccessToken(accessToken);
            response.setRefreshToken(refreshToken);
            return response;

        } catch (BadCredentialsException e) {
            int failedAttempts = credentials.getFailedAttempts() + 1;
            credentials.setFailedAttempts(failedAttempts);
            if (failedAttempts >= 5) {
                credentials.setStatus(UserStatus.LOCKED);
                credentials.setLockTime(LocalDateTime.now());
            }
            userCredentialsRepository.save(credentials);

            auditLogRepository.save(AuditLog.builder()
                    .userLogin(loginRequest.getUsername())
                    .action(AuditAction.LOGIN_FAILED.name())
                    .details("Invalid password")
                    .timestamp(LocalDateTime.now())
                    .build());

            throw new BadCredentialsException("Invalid username or password");
        }
    }

    @Transactional
    public LoginResponseDTO refreshToken(RefreshTokenRequestDTO request) {
        String username = jwtUtil.extractUsername(request.getRefreshToken());
        if (!jwtUtil.isTokenValid(request.getRefreshToken(), username)) {
            throw new IllegalArgumentException("Invalid or expired refresh token");
        }

        UserCredentials credentials = userCredentialsRepository.findByUsername(username)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        if (credentials.getStatus() != UserStatus.ACTIVE) {
            throw new IllegalArgumentException("User account is not active");
        }

        String accessToken = jwtUtil.generateAccessToken(
                credentials.getUsername(),
                credentials.getRole().getAuthority()
        );
        String refreshToken = jwtUtil.generateRefreshToken(credentials.getUsername());

        auditLogRepository.save(AuditLog.builder()
                .userLogin(username)
                .action(AuditAction.LOGIN_SUCCESS.name())
                .details("Token refreshed")
                .timestamp(LocalDateTime.now())
                .build());

        LoginResponseDTO response = new LoginResponseDTO();
        response.setAccessToken(accessToken);
        response.setRefreshToken(refreshToken);
        return response;
    }

    @Transactional
    public void logout(String token) {
        String username = jwtUtil.extractUsername(token);
        auditLogRepository.save(AuditLog.builder()
                .userLogin(username)
                .action(AuditAction.LOGOUT.name())
                .timestamp(LocalDateTime.now())
                .build());
        // Note: Token blacklisting can be added here if needed (e.g., store in Redis)
    }

    @Transactional
    public void resetPassword(PasswordResetRequestDTO request) {
        // Placeholder for email-based password reset
        // 1. Find user by email (requires Personne entity with email field)
        // 2. Generate reset token (e.g., UUID or JWT with short expiration)
        // 3. Send email with reset link (requires email service integration)
        // 4. Log action
        auditLogRepository.save(AuditLog.builder()
                .userLogin(request.getEmail())
                .action(AuditAction.PASSWORD_RESET.name())
                .details("Password reset requested")
                .timestamp(LocalDateTime.now())
                .build());
        throw new UnsupportedOperationException("Password reset not implemented yet");
    }

    @Transactional
    public void changePassword(String username, PasswordChangeRequestDTO request) {
        UserCredentials credentials = userCredentialsRepository.findByUsername(username)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        if (!passwordEncoder.matches(request.getOldPassword(), credentials.getPassword())) {
            auditLogRepository.save(AuditLog.builder()
                    .userLogin(username)
                    .action(AuditAction.PASSWORD_CHANGED.name())
                    .details("Failed: Invalid old password")
                    .timestamp(LocalDateTime.now())
                    .build());
            throw new IllegalArgumentException("Invalid old password");
        }

        credentials.setPassword(passwordEncoder.encode(request.getNewPassword()));
        credentials.setLastPasswordChange(LocalDateTime.now());
        credentials.setFailedAttempts(0);
        userCredentialsRepository.save(credentials);

        auditLogRepository.save(AuditLog.builder()
                .userLogin(username)
                .action(AuditAction.PASSWORD_CHANGED.name())
                .timestamp(LocalDateTime.now())
                .build());
    }
}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import java.util.List;

/**
 * Service interface for managing academic branches.
 * Includes CRUD operations and additional branch-related functionalities.
 */
public interface BrancheService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves branch details by ID.
     * @param id Branch's unique identifier
     * @return Branch DTO
     * @throws CustomException if branch not found
     */
    BrancheDTO findById(Long id) throws CustomException;

    /**
     * Retrieves all branches.
     * @return List of all branches
     * @throws CustomException if retrieval fails
     */
    List<BrancheDTO> findAll() throws CustomException;

    /**
     * Creates a new branch.
     * @param branche Branch DTO containing the new data
     * @return Created branch DTO
     * @throws CustomException if creation fails
     */
    BrancheDTO create(BrancheDTO branche) throws CustomException;

    /**
     * Updates an existing branch.
     * @param id Branch's unique identifier
     * @param branche Updated branch data
     * @return Updated branch DTO
     * @throws CustomException if update fails
     */
    BrancheDTO update(Long id, BrancheDTO branche) throws CustomException;

    /**
     * Deletes a branch by ID.
     * @param id Branch's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================


    /**
     * Retrieves all seances associated with a branch.
     * @param branchId Branch's unique identifier
     * @return List of courses associated with the branch
     * @throws CustomException if retrieval fails
     */
    List<SeanceDTO> getSchedule(Long branchId) throws CustomException;

    /**
     * Retrieves all students enrolled in a specific branch.
     * @param id Branch's unique identifier
     * @return List of students enrolled in this branch
     * @throws CustomException if retrieval fails or branch doesn't exist
     */
    List<EtudiantDTO> getEtudiants(Long id) throws CustomException;
}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;

import java.time.LocalDate;
import java.util.List;

/**
 * Service interface for teacher operations.
 * Manages teacher schedules, teaching hours, and communication.
 */
public interface EnseignantService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves teacher details by ID.
     * @param id Teacher's unique identifier
     * @return Teacher DTO
     * @throws CustomException if teacher not found
     */
    EnseignantDTO findById(Long id) throws CustomException;

    /**
     * Retrieves all teachers.
     * @return List of all teachers
     * @throws CustomException if retrieval fails
     */
    List<EnseignantDTO> findAll() throws CustomException;

    /**
     * Creates a new teacher.
     * @param enseignant Teacher DTO containing the new data
     * @return Created teacher DTO
     * @throws CustomException if creation fails
     */
    EnseignantDTO create(EnseignantDTO enseignant) throws CustomException;

    /**
     * Updates an existing teacher's information.
     * @param id Teacher's unique identifier
     * @param enseignant Updated teacher data
     * @return Updated teacher DTO
     * @throws CustomException if update fails
     */
    EnseignantDTO update(Long id, EnseignantDTO enseignant) throws CustomException;

    /**
     * Deletes a teacher by ID.
     * @param id Teacher's unique identifier
     * @throws CustomException if deletion fails
     */
    EnseignantDTO delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================

    /**
     * Retrieves teacher's schedule.
     * @param id Teacher's unique identifier
     * @return List of scheduled sessions
     * @throws CustomException if schedule retrieval fails
     */
    List<SeanceDTO> getSchedule(Long id) throws CustomException;

    /**
     * Calculates total teaching hours for a teacher within a specific date range.
     * @param teacherid Teacher's unique identifier
     * @param startdate Start date for calculation (format: YYYY-MM-DD)
     * @param enddate End date for calculation (format: YYYY-MM-DD)
     * @return Total hours taught between start and end date
     * @throws CustomException if calculation fails or dates are invalid
     * @apiNote Weekly sessions are counted once per week, bi-weekly (1/15) sessions
     *          count as half per week, and makeup sessions with specific dates count only once.
     */
    int getTotalTeachingHours(Long teacherid, LocalDate startdate, LocalDate enddate) throws CustomException;

    /**
     * Submits makeup session request.
     * @param id Teacher's unique identifier
     * @param proposition Makeup session proposal DTO
     * @return Created makeup session proposal DTO
     * @throws CustomException if submission fails
     */
    PropositionDeRattrapageDTO submitMakeupRequest(Long id, PropositionDeRattrapageDTO proposition) throws CustomException;

    /**
     * Submits an issue or suggestion from a teacher.
     * @param id Teacher's unique identifier
     * @param signal Signal DTO containing issue or suggestion
     * @return Created signal DTO
     * @throws CustomException if submission fails
     */
    SignalDTO submitSignal(Long id, SignalDTO signal) throws CustomException;

    /**
     * Retrieves all signals submitted by a teacher.
     * @param id Teacher's unique identifier
     * @return List of submitted signals
     * @throws CustomException if retrieval fails
     */
    List<SignalDTO> getSignals(Long id) throws CustomException;

    /**
     * Retrieves all subjects taught by a specific teacher.
     * @param id Teacher's unique identifier
     * @return List of subject names taught by the teacher
     * @throws CustomException if retrieval fails or teacher doesn't exist
     */
    List<String> getSubjects(Long id) throws CustomException;

    /**
     * Retrieves all practical groups (TPs) taught by a specific teacher.
     * @param id Teacher's unique identifier
     * @return List of practical groups (TPs) taught by the teacher
     * @throws CustomException if retrieval fails or teacher doesn't exist
     */
    List<TPDTO> getStudentGroups(Long id) throws CustomException;


}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import java.util.List;

/**
 * Service interface for student operations.
 * Manages student schedules and notifications.
 */
public interface EtudiantService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves student details by ID.
     * @param id Student's unique identifier
     * @return Student DTO
     * @throws CustomException if student not found
     */
    EtudiantDTO findById(Long id) throws CustomException;

    /**
     * Retrieves all students.
     * @return List of all students
     * @throws CustomException if retrieval fails
     */
    List<EtudiantDTO> findAll() throws CustomException;

    /**
     * Creates a new student.
     * @param etudiant Student DTO containing the new data
     * @return Created student DTO
     * @throws CustomException if creation fails
     */
    EtudiantDTO create(EtudiantDTO etudiant) throws CustomException;

    /**
     * Updates an existing student's information.
     * @param id Student's unique identifier
     * @param etudiant Updated student data
     * @return Updated student DTO
     * @throws CustomException if update fails
     */
    EtudiantDTO update(Long id, EtudiantDTO etudiant) throws CustomException;

    /**
     * Deletes a student by ID.
     * @param id Student's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================

    /**
     * Retrieves student's personal schedule.
     * @param id Student's unique identifier
     * @return List of scheduled sessions
     * @throws CustomException if schedule retrieval fails
     */
    List<SeanceDTO> getPersonalSchedule(Long id) throws CustomException;

    /**
     * Retrieves schedule for a specific branch.
     * @param id Student's unique identifier
     * @return List of scheduled sessions for branch
     * @throws CustomException if schedule retrieval fails
     */
    List<SeanceDTO> getBranchSchedule(Long id) throws CustomException;
    /**
     * Retrieves schedule for a specific branch.
     * @param id Student's unique identifier
     * @return List of scheduled sessions for branch
     * @throws CustomException if schedule retrieval fails
     */
    public List<SeanceDTO> getTDSchedule(Long id) throws CustomException;
    /**
     * Retrieves student's notifications.
     * @param id Student's unique identifier
     * @return List of notifications
     * @throws CustomException if retrieval fails
     */
    List<NotificationDTO> getNotifications(Long id) throws CustomException;
}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import java.util.List;

/**
 * Service interface for Excel file management.
 * Handles upload and tracking of Excel schedule imports.
 */
public interface ExcelFileService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves an Excel file by ID.
     * @param id Excel file's unique identifier
     * @return Excel file DTO
     * @throws CustomException if file not found
     */
    FichierExcelDTO findById(Long id) throws CustomException;

    /**
     * Retrieves all Excel files.
     * @return List of all Excel file imports
     * @throws CustomException if retrieval fails
     */
    List<FichierExcelDTO> findAll() throws CustomException;

    /**
     * Creates a new Excel file entry in the database.
     * @param fichierExcel Excel file DTO containing the data to be saved
     * @return Created Excel file DTO
     * @throws CustomException if creation fails
     */
    FichierExcelDTO create(FichierExcelDTO fichierExcel) throws CustomException;

    /**
     * Updates an existing Excel file entry.
     * @param id Excel file's unique identifier
     * @param fichierExcel Updated Excel file data
     * @return Updated Excel file DTO
     * @throws CustomException if update fails
     */
    FichierExcelDTO update(Long id, FichierExcelDTO fichierExcel) throws CustomException;

    /**
     * Deletes an Excel file entry by ID.
     * @param id Excel file's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================

    /**
     * Uploads and processes an Excel file.
     * @param file Excel file data
     * @param seanceDTOS the list of seance dtos to add to database
     * @throws CustomException if upload fails
     */
    void upload(FichierExcelDTO file , List<SeanceDTO> seanceDTOS) throws CustomException;

    /**
     * Retrieves the import history of all Excel files.
     * @return List of imported Excel files
     * @throws CustomException if retrieval fails
     */
    List<FichierExcelDTO> getImportHistory() throws CustomException;
}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import java.util.List;

/**
 * Service interface for notification management.
 * Handles system notifications and user alerts.
 */
public interface NotificationService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves a notification by ID.
     * @param id Notification's unique identifier
     * @return Notification DTO
     * @throws CustomException if notification not found
     */
    NotificationDTO findById(Long id) throws CustomException;

    /**
     * Retrieves all notifications.
     * @return List of all notifications
     * @throws CustomException if retrieval fails
     */
    List<NotificationDTO> findAll() throws CustomException;

    /**
     * Creates a new notification.
     * @param notification Notification DTO containing the data to be saved
     * @return Created Notification DTO
     * @throws CustomException if creation fails
     */
    NotificationDTO create(NotificationDTO notification) throws CustomException;

    /**
     * Updates an existing notification.
     * @param id Notification's unique identifier
     * @param notification Updated Notification DTO
     * @return Updated Notification DTO
     * @throws CustomException if update fails
     */
    NotificationDTO update(Long id, NotificationDTO notification) throws CustomException;

    /**
     * Deletes a notification by ID.
     * @param id Notification's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================

    /**
     * Marks a notification as read.
     * @param id Notification's unique identifier
     * @throws CustomException if update fails
     */
    void markAsRead(Long id) throws CustomException;

    /**
     * Retrieves unread notifications.
     * @return List of unread notifications
     * @throws CustomException if retrieval fails
     */
    List<NotificationDTO> getUnreadNotifications() throws CustomException;

    /**
     * Broadcasts a notification to all users.
     * @param notificationDTO Notification data to be broadcasted usually recepteur is empty
     * @throws CustomException if broadcasting fails
     */
    void broadcastNotification(NotificationDTO notificationDTO) throws CustomException;

    /**
     * Sends a notification to all teachers in the system.
     * @param notificationDTO Notification content and metadata
     * @throws CustomException if sending fails or notification is invalid
     */
    void sendNotificationToTeachers(NotificationDTO notificationDTO) throws CustomException;


    /**
     * Sends a notification to all students in the system.
     * @param notificationDTO Notification content and metadata
     * @throws CustomException if sending fails or notification is invalid
     */
    void sendNotificationToStudents(NotificationDTO notificationDTO) throws CustomException;

    /**
     * Sends a notification to students in multiple branches.
     * @param notificationDTO Notification content and metadata
     * @param brancheDTOS List of branches whose students should receive the notification
     * @throws CustomException if sending fails or any input is invalid
     */
    void sendNotificationToBranches(NotificationDTO notificationDTO,List<BrancheDTO> brancheDTOS) throws CustomException;

    /**
     * Sends a notification to all students in a specific branch.
     * @param notificationDTO Notification content and metadata
     * @param brancheDTOS Branch whose students should receive the notification
     * @throws CustomException if sending fails or any input is invalid
     */
    void sendNotificationToBranche(NotificationDTO notificationDTO,BrancheDTO brancheDTOS) throws CustomException;

    /**
     * Sends a notification to students in multiple tutorial groups (TDs).
     * @param notificationDTO Notification content and metadata
     * @param tddtos List of tutorial groups whose students should receive the notification
     * @throws CustomException if sending fails or any input is invalid
     */
    void sendNotificationToTDs(NotificationDTO notificationDTO,List<TDDTO> tddtos) throws CustomException;

    /**
     * Sends a notification to all students in a specific tutorial group (TD).
     * @param notificationDTO Notification content and metadata
     * @param tddto Tutorial group whose students should receive the notification
     * @throws CustomException if sending fails or any input is invalid
     */
    void sendNotificationToTD(NotificationDTO notificationDTO,TDDTO tddto) throws CustomException;

    /**
     * Sends a notification to students in multiple practical groups (TPs).
     * @param notificationDTO Notification content and metadata
     * @param tpdtos List of practical groups whose students should receive the notification
     * @throws CustomException if sending fails or any input is invalid
     */
    void sendNotificationToTPs(NotificationDTO notificationDTO,List<TPDTO> tpdtos) throws CustomException;

    /**
     * Sends a notification to all students in a specific practical group (TP).
     * @param notificationDTO Notification content and metadata
     * @param tpdto Practical group whose students should receive the notification
     * @throws CustomException if sending fails or any input is invalid
     */
    void sendNotificationToTP(NotificationDTO notificationDTO,TPDTO tpdto) throws CustomException;


}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;

/**
 * Service interface for room management.
 * Handles CRUD operations and availability checking for rooms.
 */
public interface SalleService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves a room by its ID.
     * @param id Room's unique identifier
     * @return Room DTO
     * @throws CustomException if room not found
     */
    SalleDTO findById(Long id) throws CustomException;

    /**
     * Retrieves all rooms.
     * @return List of all rooms
     * @throws CustomException if retrieval fails
     */
    List<SalleDTO> findAll() throws CustomException;

    /**
     * Creates a new room.
     * @param salle Room data to be saved
     * @return Created room
     * @throws CustomException if creation fails
     */
    SalleDTO create(SalleDTO salle) throws CustomException;

    /**
     * Updates an existing room.
     * @param id Room's unique identifier
     * @param salle Updated room data
     * @return Updated room
     * @throws CustomException if update fails
     */
    SalleDTO update(Long id, SalleDTO salle) throws CustomException;

    /**
     * Deletes a room.
     * @param id Room's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================

    /**
     * Finds available rooms for a specific time slot.
     * @param date Desired date in format YYYY-MM-DD (can be null for recurring slots)
     * @param day Day of week (e.g., "MONDAY" or "lundi")
     * @param startTime Start time in format HH:mm
     * @param endTime End time in format HH:mm
     * @return List of available rooms during the specified time slot
     * @throws CustomException if search fails, time format is invalid, or parameters are inconsistent
     * @apiNote If date is not specified, the method will check for regular weekly availability
     */
    List<SalleDTO> getAvailableRooms(LocalDate date, DayOfWeek day, LocalTime startTime, LocalTime endTime) throws CustomException;



}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import java.util.List;

/**
 * Service interface for session management.
 * Handles CRUD operations and conflict detection for teaching sessions.
 */
public interface SeanceService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves all teaching sessions.
     * @return List of all sessions
     * @throws CustomException if retrieval fails
     */
    List<SeanceDTO> findAll() throws CustomException;

    /**
     * Retrieves session by ID.
     * @param id Session's unique identifier
     * @return Session DTO
     * @throws CustomException if session not found
     */
    SeanceDTO findById(Long id) throws CustomException;

    /**
     * Creates a new teaching session.
     * @param seance Session data to be created
     * @return Created session
     * @throws CustomException if creation fails
     */
    SeanceDTO create(SeanceDTO seance) throws CustomException;

    /**
     * Updates an existing teaching session.
     * @param id Session's unique identifier
     * @param seance Updated session data
     * @return Updated session
     * @throws CustomException if update fails
     */
    SeanceDTO update(Long id, SeanceDTO seance) throws CustomException;

    /**
     * Deletes a teaching session.
     * @param id Session's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================

    /**
     * Retrieves all session conflicts.
     * @return List of session conflicts
     * @throws CustomException if retrieval fails
     */
    List<SeanceConflictDTO> getAllConflicts() throws CustomException;


    /**
     * Retrieves all room conflicts.
     * @return List of room conflicts
     * @throws CustomException if retrieval fails
     */
    List<SeanceRoomConflictDTO> getRoomConflicts() throws CustomException;

    /**
     * Retrieves conflicts for a specific session.
     * @param seanceId Session's unique identifier
     * @return List of conflicts for the given session
     * @throws CustomException if retrieval fails
     */
    List<SingleSeanceConflictDTO> getConflictsForSession(Long seanceId) throws CustomException;

    /**
     * Retrieves conflicts for a specific session.
     * @param seanceDto a mock sessionDto ( without id) just to transfer query params
     * @return List of conflicts for the given session
     * @throws CustomException if retrieval fails
     */
    List<SingleSeanceConflictDTO> getConflictsForSession(SeanceDTO seanceDto) throws CustomException;

}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import java.util.List;

/**
 * Service interface for tutorial group management.
 * Handles operations related to tutorial sessions.
 */
public interface TDService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves all tutorial groups.
     * @return List of all tutorial groups
     * @throws CustomException if retrieval fails
     */
    List<TDDTO> findAll() throws CustomException;

    /**
     * Retrieves tutorial group by ID.
     * @param id Tutorial group's unique identifier
     * @return Tutorial group DTO
     * @throws CustomException if group not found
     */
    TDDTO findById(Long id) throws CustomException;

    /**
     * Creates a new tutorial group.
     * @param td Tutorial group data to be created
     * @return Created tutorial group DTO
     * @throws CustomException if creation fails
     */
    TDDTO create(TDDTO td) throws CustomException;

    /**
     * Updates an existing tutorial group.
     * @param id Tutorial group's unique identifier
     * @param td Updated tutorial group data
     * @return Updated tutorial group DTO
     * @throws CustomException if update fails
     */
    TDDTO update(Long id, TDDTO td) throws CustomException;

    /**
     * Deletes a tutorial group.
     * @param id Tutorial group's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================

    /**
     * Retrieves practical sessions for a specific tutorial group.
     * @param tdId Tutorial group's unique identifier
     * @return List of practical sessions (TP)
     * @throws CustomException if retrieval fails
     */
    List<TPDTO> getTPs(Long tdId) throws CustomException;
    /**
     * Generates a complete schedule for a tutorial group (TD), including its branch sessions.
     * @param id Tutorial group's (TD) unique identifier
     * @return List of sessions (Seances) in the generated schedule
     * @throws CustomException if generation fails or TD doesn't exist
     */
    List<SeanceDTO> generateSchedule(Long id) throws CustomException;

    /**
     * Retrieves all students enrolled in a specific tutorial group (TD).
     * @param id Tutorial group's (TD) unique identifier
     * @return List of students enrolled in this tutorial group
     * @throws CustomException if retrieval fails or TD doesn't exist
     */
    List<EtudiantDTO> getEtudiants(Long id) throws CustomException;

}
package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.TechnicienDTO;
import com.scheduling.universityschedule_backend.dto.SalleDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import java.util.List;

/**
 * Service interface for technician operations.
 * Focuses on technical maintenance and resource management.
 * Note: User management functionality will be handled separately by authentication services.
 *
 * @author Mahmoud-ABK
 * @version 1.0
 * @since 2025-05-04
 */
public interface TechnicienService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves technician details by ID.
     *
     * @param id Technician's unique identifier
     * @return Technician DTO
     * @throws CustomException if technician not found
     */
    TechnicienDTO findById(Long id) throws CustomException;

    /**
     * Retrieves all technicians.
     *
     * @return List of all technicians
     * @throws CustomException if retrieval fails
     */
    List<TechnicienDTO> findAll() throws CustomException;

    /**
     * Creates a new technician.
     *
     * @param technicien Technician DTO containing the new data
     * @return Created technician DTO
     * @throws CustomException if creation fails
     */
    TechnicienDTO create(TechnicienDTO technicien) throws CustomException;

    /**
     * Updates an existing technician's information.
     *
     * @param id         Technician's unique identifier
     * @param technicien Updated technician data
     * @return Updated technician DTO
     * @throws CustomException if update fails
     */
    TechnicienDTO update(Long id, TechnicienDTO technicien) throws CustomException;

    /**
     * Deletes a technician by ID.
     *
     * @param id Technician's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;

}package com.scheduling.universityschedule_backend.service;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import java.util.List;

/**
 * Service interface for practical session management.
 * Handles operations related to practical/lab sessions.
 */
public interface TPService {

    // ============================
    //          CRUD Operations
    // ============================

    /**
     * Retrieves all practical sessions.
     * @return List of all practical sessions
     * @throws CustomException if retrieval fails
     */
    List<TPDTO> findAll() throws CustomException;

    /**
     * Retrieves practical session by ID.
     * @param id Practical session's unique identifier
     * @return Practical session DTO
     * @throws CustomException if session not found
     */
    TPDTO findById(Long id) throws CustomException;

    /**
     * Creates a new practical session.
     * @param tp Practical session data to be created
     * @return Created practical session DTO
     * @throws CustomException if creation fails
     */
    TPDTO create(TPDTO tp) throws CustomException;

    /**
     * Updates an existing practical session.
     * @param id Practical session's unique identifier
     * @param tp Updated practical session data
     * @return Updated practical session DTO
     * @throws CustomException if update fails
     */
    TPDTO update(Long id, TPDTO tp) throws CustomException;

    /**
     * Deletes a practical session.
     * @param id Practical session's unique identifier
     * @throws CustomException if deletion fails
     */
    void delete(Long id) throws CustomException;


    // ============================
    //          Functionalities
    // ============================

    /**
     * Retrieves students enrolled in a practical session.
     * @param tpId Practical session's unique identifier
     * @return List of students enrolled in the practical session
     * @throws CustomException if retrieval fails
     */
    List<EtudiantDTO> getStudents(Long tpId) throws CustomException;

    /**
     * Generates a complete schedule for a practical group (TP), including its TD and branch sessions.
     * @param id Practical group's (TP) unique identifier
     * @return List of sessions (Seances) in the generated schedule
     * @throws CustomException if generation fails or TP doesn't exist
     */
    List<SeanceDTO> generateSchedule(Long id) throws CustomException;

    /**
     * Retrieves all students enrolled in a specific practical group (TP).
     * @param id Practical group's (TP) unique identifier
     * @return List of students enrolled in this practical group
     * @throws CustomException if retrieval fails or TP doesn't exist
     */
    List<EtudiantDTO> getEtudiants(Long id) throws CustomException;


}
