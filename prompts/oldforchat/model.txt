package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

@EqualsAndHashCode(callSuper = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "administrateurs")
@ToString(callSuper = true)
public class Administrateur extends Personne {
    private String codeAdmin;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "audit_logs", indexes = {
        @Index(name = "idx_user_login", columnList = "user_login"),
        @Index(name = "idx_timestamp", columnList = "timestamp")
})
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AuditLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime timestamp;

    @Column(name = "user_login", nullable = false)
    private String userLogin;

    @Column(nullable = false)
    private String action;

    @Column(name = "entity_type")
    private String entityType;

    @Column(name = "entity_id")
    private Long entityId;

    @Column(columnDefinition = "TEXT")
    private String details;
}package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "branches", indexes = {
        @Index(name = "idx_branche_niveau_specialite", columnList = "niveau,specialite")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@NamedEntityGraph(
    name = "Branche.withSeances",
    attributeNodes = @NamedAttributeNode("seances")
)
@ToString(exclude = {"seances"})
public class Branche {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String niveau;
    private String specialite;
    private int nbTD;
    private String departement;

    @OneToMany(mappedBy ="branche", fetch = FetchType.LAZY, cascade = CascadeType.ALL , orphanRemoval = true)
    private List<TD> tds;

    @ManyToMany(mappedBy = "branches" , fetch = FetchType.LAZY , cascade = CascadeType.ALL)
    private List<PropositionDeRattrapage> propositionDeRattrapages = new ArrayList<>() ;

    @ManyToMany(mappedBy = "branches", fetch = FetchType.LAZY, cascade = {CascadeType.REMOVE})
    private List<Seance> seances;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.util.List;

@Entity
@Table(name = "enseignants")
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@ToString(exclude = {"seances", "propositionsDeRattrapage", "signals"})
public class Enseignant extends Personne {
    private String codeEnseignant;
    private int heures;

    @OneToMany(mappedBy = "enseignant", fetch = FetchType.LAZY, cascade = CascadeType.ALL , orphanRemoval = true)
    private List<Seance> seances;

    @OneToMany(mappedBy = "enseignant", fetch = FetchType.LAZY, cascade = CascadeType.ALL , orphanRemoval = true)
    private List<PropositionDeRattrapage> propositionsDeRattrapage;

    @OneToMany(mappedBy = "enseignant", fetch = FetchType.LAZY, cascade = CascadeType.ALL , orphanRemoval = true)
    private List<Signal> signals;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity
@Table(name = "etudiants")
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@ToString(exclude = {"branche", "tp"})
public class Etudiant extends Personne {
    private String matricule;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branche_id")
    private Branche branche;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="tp_id")
    private TP tp;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "fichiers_excel")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FichierExcel {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String fileName;
    private String status;

    @ElementCollection
    private List<String> errors;

    private LocalDateTime importDate;
}
package com.scheduling.universityschedule_backend.model;

/**
 * Enum representing the frequency type of a session (Seance).
 * Used to indicate whether a session occurs weekly, biweekly, or is a makeup session.
 */
public enum FrequenceType {
    /**
     * Session occurs every week
     */
    WEEKLY,

    /**
     * Session occurs every other week (once per two weeks)
     */
    BIWEEKLY,

    /**
     * Session is a one-time makeup session
     */
    CATCHUP;

    /**
     * Convert a string representation to FrequenceType enum
     * @param value String value to convert
     * @return Corresponding FrequenceType or null if no match
     */
    public static FrequenceType fromString(String value) {
        if (value == null) {
            return null;
        }

        return switch (value.toLowerCase()) {
            case "weekly" -> WEEKLY;
            case "1/1" -> WEEKLY;
            case "biweekly" -> BIWEEKLY;
            case "1/15" -> BIWEEKLY;
            case "makeup", "catch-up"  -> CATCHUP;
            default -> null;
        };
    }

    /**
     * Convert FrequenceType to its string representation
     * @return String representation of frequency type
     */
    @Override
    public String toString() {
        return switch (this) {
            case WEEKLY -> "weekly";
            case BIWEEKLY -> "1/15";
            case CATCHUP -> "catch-up";
        };
    }
}package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.time.LocalDateTime;

@Entity
@Table(name = "notification", indexes = {
        @Index(name = "idx_notification_recepteur", columnList = "recepteur_id"),
        @Index(name = "idx_notification_date", columnList = "date"),
        @Index(name = "idx_notification_isread", columnList = "isread")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"recepteur", "expediteur"})
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String message;
    private LocalDateTime date;
    private String type;
    private Boolean isread;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "recepteur_id")
    private Personne recepteur;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "expediteur_id")
    private Personne expediteur;

    public boolean isRead() {
        return isread;
    }
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.util.List;

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Personne {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String cin;
    private String nom;
    private String prenom;
    private String email;
    private String tel;
    private String adresse;

    @OneToMany(mappedBy = "recepteur", cascade = CascadeType.REMOVE)
    private List<Notification> receivednotifications;
    @OneToMany(mappedBy = "expediteur", cascade = CascadeType.REMOVE)
    private List<Notification> sentnotifications;

}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "propositions_de_rattrapage", indexes = {
        @Index(name = "idx_proposition_date", columnList = "date"),
        @Index(name = "idx_proposition_status", columnList = "status"),
        @Index(name = "idx_proposition_type", columnList = "type"),
        @Index(name = "idx_proposition_enseignant", columnList = "enseignant_id")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"enseignant", "branches", "tds", "tps"})
public class PropositionDeRattrapage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String matiere;

    @Enumerated(EnumType.STRING)
    private SeanceType type;  // New field for session type

    private LocalTime heureDebut;
    private LocalTime heureFin;
    private LocalDateTime date;

    private String reason;
    private Status status =Status.PENDING;



    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "enseignant_id")
    private Enseignant enseignant;

    @ManyToMany(fetch = FetchType.LAZY,cascade = CascadeType.ALL)
    @JoinTable(
            name = "proposition_branche",
            joinColumns = @JoinColumn(name = "proposition_id"),
            inverseJoinColumns = @JoinColumn(name = "branche_id")
    )
    private List<Branche> branches = new ArrayList<>();

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "proposition_td",
            joinColumns = @JoinColumn(name = "proposition_id"),
            inverseJoinColumns = @JoinColumn(name = "td_id")
    )
    private List<TD> tds = new ArrayList<>();

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "proposition_tp",
            joinColumns = @JoinColumn(name = "proposition_id"),
            inverseJoinColumns = @JoinColumn(name = "tp_id")
    )
    private List<TP> tps = new ArrayList<>();
}package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.util.List;

@Entity
@Table(name = "salles", indexes = {
        @Index(name = "idx_salle_identifiant", columnList = "identifiant"),
        @Index(name = "idx_salle_type", columnList = "type"),
        @Index(name = "idx_salle_capacite", columnList = "capacite")})
@Data
@NoArgsConstructor
@AllArgsConstructor
@NamedEntityGraph(
    name = "Salle.withSeances",
    attributeNodes = @NamedAttributeNode("seances")
)
public class Salle {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String identifiant;
    private String type;
    private int capacite;

    @OneToMany(mappedBy = "salle", fetch = FetchType.LAZY, cascade = CascadeType.ALL , orphanRemoval = true)
    private List<Seance> seances;



    @Override
    public String toString() {
        return "Salle{id=" + id +
                ", identifiant='" + identifiant + '\'' +
                ", type='" + type + '\'' +
                ", capacite=" + capacite +
                ", seancesCount=" + (seances != null ? seances.size() : "N/A") +
                '}';
    }
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.*;
import org.springframework.lang.Nullable;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "seances", indexes = {
        @Index(name = "idx_seance_jour", columnList = "jour"),
        @Index(name = "idx_seance_time_range", columnList = "heureDebut,heureFin"),
        @Index(name = "idx_seance_enseignant", columnList = "enseignant_id"),
        @Index(name = "idx_seance_salle", columnList = "salle_id"),
        @Index(name = "idx_seance_frequence", columnList = "frequence"),
        @Index(name = "idx_seance_date", columnList = "date")
})
@Getter @Setter @NoArgsConstructor @AllArgsConstructor
@ToString
public class Seance {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String matiere;

    @Enumerated(EnumType.STRING)
    private DayOfWeek jour;

    @Enumerated(EnumType.STRING)
    private SeanceType type;    // New field for session type (CI, CR, TD, TP)


    private LocalTime heureDebut;
    private LocalTime heureFin;

    @Enumerated(EnumType.STRING)
    private FrequenceType frequence = FrequenceType.WEEKLY;

    // New field for makeup sessions
    @Nullable
    private LocalDate date;

    @ManyToOne
    @JoinColumn(name = "salle_id")
    private Salle salle;

    @ManyToOne
    @JoinColumn(name = "enseignant_id")
    private Enseignant enseignant;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "seance_branche",
            joinColumns = @JoinColumn(name = "seance_id"),
            inverseJoinColumns = @JoinColumn(name = "branche_id")
    )
    private List<Branche> branches = new ArrayList<>();

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "seance_td",
            joinColumns = @JoinColumn(name = "seance_id"),
            inverseJoinColumns = @JoinColumn(name = "td_id")
    )
    private List<TD> tds = new ArrayList<>();

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
            name = "seance_tp",
            joinColumns = @JoinColumn(name = "seance_id"),
            inverseJoinColumns = @JoinColumn(name = "tp_id")
    )
    private List<TP> tps = new ArrayList<>();
}package com.scheduling.universityschedule_backend.model;

/**
 * Enum representing the type of a session.
 * CI: Cours Intégré (Integrated Course)
 * CR: Cours (Lecture)
 * TD: Travaux Dirigés (Tutorial)
 * TP: Travaux Pratiques (Practical Work)
 */
public enum SeanceType {
    CI,  // Cours Intégré
    CR,  // Cours
    TD,  // Travaux Dirigés
    TP   // Travaux Pratiques
}package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.time.LocalDateTime;

@Entity
@Table(name = "signals")
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"enseignant"})
public class Signal {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String message;
    private String severity;
    private LocalDateTime timestamp;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "enseignant_id")
    private Enseignant enseignant;
}
package com.scheduling.universityschedule_backend.model;

/**
 * Enum representing the status of a makeup session proposal (PropositionDeRattrapage).
 *
 * The status tracks the administrative lifecycle of a proposal:
 *
 * <ul>
 *     <li>{@code PENDING} — Default state when a proposal is first submitted. Awaiting review.</li>
 *     <li>{@code SCHEDULED} — The proposal has been accepted but not yet assigned a room. Awaiting finalization.</li>
 *     <li>{@code APPROVED} — The makeup session has been officially validated and assigned a room. A Seance has been created.</li>
 *     <li>{@code REJECTED} — The proposal has been declined. It will not be scheduled or transformed into a session.</li>
 * </ul>
 *
 * These states are used in the administrative workflow for managing and validating proposed catch-up sessions.
 */
public enum Status {
    PENDING,
    SCHEDULED,
    APPROVED,
    REJECTED
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "tds", indexes = {
        @Index(name = "idx_td_branche", columnList = "branche_id")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"tpList", "seances"})
public class TD {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int nb;
    private int nbTP;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branche_id")
    private Branche branche;

    @OneToMany(mappedBy = "td", fetch = FetchType.LAZY, cascade = CascadeType.ALL , orphanRemoval = true)
    private List<TP> tpList;

    @ManyToMany(mappedBy = "tds", fetch = FetchType.LAZY,cascade = CascadeType.ALL)
    private List<Seance> seances;

    @ManyToMany(mappedBy = "tds" , fetch = FetchType.LAZY , cascade = CascadeType.ALL)
    private List<PropositionDeRattrapage> propositionDeRattrapages = new ArrayList<>() ;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@EqualsAndHashCode(callSuper = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "techniciens")
public class Technicien extends Personne {
    private String codeTechnicien;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "tps", indexes = {
        @Index(name = "idx_tp_td", columnList = "td_id")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"etudiants", "seances"})
public class TP {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int nb;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "td_id")
    private TD td;

    @OneToMany(mappedBy = "tp", fetch = FetchType.LAZY, cascade = CascadeType.ALL , orphanRemoval = true)
    private List<Etudiant> etudiants;

    @ManyToMany(mappedBy = "tps", fetch = FetchType.LAZY, cascade = CascadeType.ALL )
    private List<Seance> seances;

    @ManyToMany(mappedBy = "tps" , fetch = FetchType.LAZY , cascade = CascadeType.ALL)
    private List<PropositionDeRattrapage> propositionDeRattrapages = new ArrayList<>() ;

    @PreRemove
    private void removeTPFromSeances() {
        for (Seance seance : this.seances) {
            seance.getTps().remove(this);
        }
    }
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import com.scheduling.universityschedule_backend.model.enums.UserRole;
import com.scheduling.universityschedule_backend.model.enums.UserStatus;

import java.time.LocalDateTime;

@Entity
@Table(name = "user_credentials", indexes = {
        @Index(name = "idx_username", columnList = "username"),
        @Index(name = "idx_personne_id", columnList = "personne_id")
})
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCredentials {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinColumn(name = "personne_id", nullable = false)
    private Personne personne;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(name = "last_password_change")
    private LocalDateTime lastPasswordChange;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private UserStatus status;

    @Column(name = "failed_attempts")
    private Integer failedAttempts;

    @Column(name = "lock_time")
    private LocalDateTime lockTime;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    private UserRole role;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        if (failedAttempts == null) {
            failedAttempts = 0;
        }
        if (status == null) {
            status = UserStatus.ACTIVE;
        }
        if (lastPasswordChange == null) {
            lastPasswordChange = LocalDateTime.now();
        }
    }
}