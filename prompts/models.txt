package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@EqualsAndHashCode(callSuper = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "administrateurs")
public class Administrateur extends Personne {
    private String codeAdmin;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "branches")
public class Branche {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String niveau;
    private String specialite;
    private int nbTD;
    private String departement;

    // Inverse side for many-to-many with Seance
    @ManyToMany(mappedBy = "branches",fetch = FetchType.EAGER)
    private List<Seance> seances;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import java.util.List;

@EqualsAndHashCode(callSuper = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "enseignants")
public class Enseignant extends Personne {
    private String codeEnseignant;
    private int heures;

    @OneToMany(mappedBy = "enseignant",fetch = FetchType.EAGER)
    private List<Seance> seances;

    @OneToMany(mappedBy = "enseignant" ,fetch = FetchType.EAGER)
    private List<PropositionDeRattrapage> propositionsDeRattrapage;

    @OneToMany(mappedBy = "enseignant" ,fetch = FetchType.EAGER)
    private  List<Signal> signals;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.Entity;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.JoinTable;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import java.util.List;

@EqualsAndHashCode(callSuper = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "etudiants")
public class Etudiant extends Personne {
    private String matricule;

    @ManyToOne
    @JoinColumn(name = "branche_id")
    private Branche branche;

    @ManyToOne
    @JoinColumn(name="tp_id")
    private TP tp;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "fichiers_excel")
public class FichierExcel {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String fileName;
    private String status;

    @ElementCollection
    private List<String> errors;

    private LocalDateTime importDate;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "notifications")
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String message;
    private LocalDateTime date;
    private String type;
    private Boolean read;

    @ManyToOne
    @JoinColumn(name = "recepteur_id")
    private Personne recepteur;

    @ManyToOne
    @JoinColumn(name = "expediteur_id")
    private Personne expediteur;

    public boolean isRead() {
        return read;
    }
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Inheritance(strategy = InheritanceType.JOINED) // Creates a separate table for each subclass
public class Personne {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String cin;
    private String nom;
    private String prenom;
    private String email;
    private String tel;
    private String adresse;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "propositions_de_rattrapage")
public class PropositionDeRattrapage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private LocalDateTime date;
    private String reason;
    private String status;

    @ManyToOne
    @JoinColumn(name = "enseignant_id")
    private Enseignant enseignant;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "salles")
public class Salle {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String identifiant;
    private String type;
    private int capacite;

    @OneToMany(mappedBy = "salle",fetch = FetchType.EAGER)
    private List<Seance> seances;

    @ElementCollection
    private List<String> disponibilite;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.annotation.Nullable;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "seances")
public class Seance {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String jour;
    private String heureDebut;
    private String heureFin;
    private String type; // possible values CR-CI-TD-TP
    private String matiere;

    @Nullable
    private String frequence;
    // Possible values:
    //  - Empty string for weekly sessions (in which case each list below must have exactly one element)
    //  - "1/15" for biweekly sessions (lists can have more than one element to assign different groups)
    //  - A specific session date for catchup sessions

    @ManyToOne
    @JoinColumn(name = "salle_id")
    private Salle salle;

    @ManyToOne
    @JoinColumn(name = "enseignant_id")
    private Enseignant enseignant;

    // Use a many-to-many relationship for groups, with business logic to enforce
    // one single association for weekly sessions and multiple for biweekly sessions.

    // For Branch: normally one branch; multiple allowed if biweekly.
    @ManyToMany
    @JoinTable(
            name = "seance_branche",
            joinColumns = @JoinColumn(name = "seance_id"),
            inverseJoinColumns = @JoinColumn(name = "branche_id")
    )
    private List<Branche> branches;

    // For TD: normally one TD; multiple allowed if biweekly.
    @ManyToMany
    @JoinTable(
            name = "seance_td",
            joinColumns = @JoinColumn(name = "seance_id"),
            inverseJoinColumns = @JoinColumn(name = "td_id")
    )
    private List<TD> tds;

    // For TP: normally one TP; multiple allowed if biweekly.
    @ManyToMany
    @JoinTable(
            name = "seance_tp",
            joinColumns = @JoinColumn(name = "seance_id"),
            inverseJoinColumns = @JoinColumn(name = "tp_id")
    )
    private List<TP> tps;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "signals")
public class Signal {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String message;
    private String severity;
    private LocalDateTime timestamp;
    @ManyToOne
    @JoinColumn(name = "enseignant_id")
    private Enseignant enseignant;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "tds")
public class TD {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int nb;
    private int nbTP;

    @ManyToOne
    @JoinColumn(name = "branche_id")
    private Branche branche;

    @OneToMany(mappedBy = "td",fetch = FetchType.EAGER)
    private List<TP> tpList;

    // Inverse side for many-to-many with Seance
    @ManyToMany(mappedBy = "tds",fetch = FetchType.EAGER)
    private List<Seance> seances;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@EqualsAndHashCode(callSuper = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "techniciens")
public class Technicien extends Personne {
    private String codeTechnicien;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "tps")
public class TP {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int nb;

    @ManyToOne
    @JoinColumn(name = "td_id")
    private TD td;

    @OneToMany(mappedBy = "tp",fetch = FetchType.EAGER)
    private List<Etudiant> etudiants;

    // Inverse side for many-to-many with Seance
    @ManyToMany(mappedBy = "tps",fetch = FetchType.EAGER)
    private List<Seance> seances;
}
