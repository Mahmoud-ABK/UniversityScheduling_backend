package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.AdministrateurDTO;
import com.scheduling.universityschedule_backend.dto.PropositionDeRattrapageDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.*;
import com.scheduling.universityschedule_backend.repository.AdministrateurRepository;
import com.scheduling.universityschedule_backend.repository.PropositionDeRattrapageRepository;
import com.scheduling.universityschedule_backend.repository.SalleRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.AdministrateurService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service implementation for administrator operations.
 * Handles schedule management, makeup sessions, and system-wide notifications.
 */
@Service
@Transactional
public class AdministrateurServiceImpl implements AdministrateurService {

    /**
     * Status constants for makeup session proposals
     */
    private static final String STATUS_APPROVED = "approved";
    private static final String STATUS_REJECTED = "rejected";

    private final AdministrateurRepository administrateurRepository;
    private final PropositionDeRattrapageRepository propositionDeRattrapageRepository;
    private final EntityMapper entityMapper;
    private final SalleRepository salleRepository;
    private final SeanceRepository seanceRepository;


    /**
     * Constructor injection for dependencies
     */
    public AdministrateurServiceImpl(AdministrateurRepository administrateurRepository,
                                     PropositionDeRattrapageRepository propositionDeRattrapageRepository,
                                     EntityMapper entityMapper, SalleRepository salleRepository,SeanceRepository seanceRepository) {
        this.administrateurRepository = administrateurRepository;
        this.propositionDeRattrapageRepository = propositionDeRattrapageRepository;
        this.entityMapper = entityMapper;
        this.salleRepository = salleRepository;
        this.seanceRepository = seanceRepository;

    }

    @Override
    public AdministrateurDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Administrator ID cannot be null");
            }

            // Retrieve administrator
            Administrateur administrateur = administrateurRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Administrator not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toAdministrateurDTO(administrateur);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve administrator with ID: " + id, e);
        }
    }

    @Override
    public List<AdministrateurDTO> findAll() throws CustomException {
        try {
            // Retrieve all administrators
            List<Administrateur> administrateurs = administrateurRepository.findAll();

            // Handle empty list case
            if (administrateurs.isEmpty()) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return administrateurs.stream()
                    .map(entityMapper::toAdministrateurDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all administrators", e);
        }
    }

    @Override
    public AdministrateurDTO create(AdministrateurDTO administrateurDTO) throws CustomException {
        try {
            // Validate input
            if (administrateurDTO == null) {
                throw new CustomException("Administrator data cannot be null");
            }

            // Check for duplicate ID if provided
            if (administrateurDTO.getId() != null && administrateurRepository.existsById(administrateurDTO.getId())) {
                throw new CustomException("Administrator with ID " + administrateurDTO.getId() + " already exists");
            }

            // Convert to entity
            Administrateur administrateur = entityMapper.toAdministrateur(administrateurDTO);

            // Save entity
            Administrateur savedAdministrateur = administrateurRepository.save(administrateur);

            // Convert back to DTO
            return entityMapper.toAdministrateurDTO(savedAdministrateur);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create administrator", e);
        }
    }

    @Override
    public AdministrateurDTO update(Long id, AdministrateurDTO administrateurDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Administrator ID cannot be null");
            }

            if (administrateurDTO == null) {
                throw new CustomException("Administrator data cannot be null");
            }

            // Find existing administrator
            Administrateur existingAdministrateur = administrateurRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Administrator not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(administrateurDTO, existingAdministrateur);

            // Save updated entity
            Administrateur updatedAdministrateur = administrateurRepository.save(existingAdministrateur);

            // Convert back to DTO
            return entityMapper.toAdministrateurDTO(updatedAdministrateur);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update administrator with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Administrator ID cannot be null");
            }

            // Check if administrator exists
            if (!administrateurRepository.existsById(id)) {
                throw new CustomException("Administrator not found with ID: " + id);
            }

            // Delete administrator
            administrateurRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete administrator with ID: " + id, e);
        }
    }

    @Override
    public List<PropositionDeRattrapageDTO> getAllMakeupSessions() throws CustomException {
        try {
            // Retrieve all makeup session proposals
            List<PropositionDeRattrapage> propositions = propositionDeRattrapageRepository.findAll();

            // Handle empty list case
            if (propositions.isEmpty()) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return propositions.stream()
                    .map(entityMapper::toPropositionDeRattrapageDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve makeup session proposals", e);
        }
    }
    // still needs refinement
    // In AdministrateurServiceImpl.java
    @Override
    public PropositionDeRattrapageDTO approveMakeupSession(Long id, Long salleId) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Makeup session proposal ID cannot be null");
            }

            // Find existing makeup session proposal
            PropositionDeRattrapage proposition = propositionDeRattrapageRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Makeup session proposal not found with ID: " + id));

            if (proposition.getStatus() == Status.APPROVED) {
                throw new CustomException("Makeup session proposal is already approved");
            }

            if (salleId == null) {
                // Set status to SCHEDULED if no room is assigned
                proposition.setStatus(Status.SCHEDULED);
                PropositionDeRattrapage savedProposition = propositionDeRattrapageRepository.save(proposition);
                return entityMapper.toPropositionDeRattrapageDTO(savedProposition);
            } else {
                // Find the room
                Salle salle = salleRepository.findById(salleId)
                        .orElseThrow(() -> new CustomException("Room not found with ID: " + salleId));

                // Create new Seance from proposition
                Seance newSeance = new Seance();
                newSeance.setName(proposition.getName());
                newSeance.setMatiere(proposition.getMatiere());
                newSeance.setType(proposition.getType());
                newSeance.setHeureDebut(proposition.getHeureDebut());
                newSeance.setHeureFin(proposition.getHeureFin());
                newSeance.setDate(proposition.getDate().toLocalDate());
                newSeance.setJour(proposition.getDate().getDayOfWeek());
                newSeance.setFrequence(FrequenceType.CATCHUP);
                newSeance.setSalle(salle);
                newSeance.setEnseignant(proposition.getEnseignant());
                newSeance.setBranches(new ArrayList<>(proposition.getBranches()));
                newSeance.setTds(new ArrayList<>(proposition.getTds()));
                newSeance.setTps(new ArrayList<>(proposition.getTps()));

                // Save the new Seance
                seanceRepository.save(newSeance);

                // Update proposition status
                proposition.setStatus(Status.APPROVED);
                PropositionDeRattrapage savedProposition = propositionDeRattrapageRepository.save(proposition);

                return entityMapper.toPropositionDeRattrapageDTO(savedProposition);
            }
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to process makeup session proposal with ID: " + id, e);
        }
    }

    @Override
    public PropositionDeRattrapageDTO rejectMakeupSession(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Makeup session proposal ID cannot be null");
            }

            // Find existing makeup session proposal
            PropositionDeRattrapage proposition = propositionDeRattrapageRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Makeup session proposal not found with ID: " + id));

            // Validate current status
            if (proposition.getStatus() == Status.REJECTED) {
                return entityMapper.toPropositionDeRattrapageDTO(proposition); // Already rejected, no need to update
            }

            if (proposition.getStatus() == Status.APPROVED) {
                throw new CustomException("Cannot reject: makeup session proposal already approved");
            }

            // Update status to rejected
            proposition.setStatus(Status.REJECTED);
            propositionDeRattrapageRepository.save(proposition);
            return entityMapper.toPropositionDeRattrapageDTO(proposition);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to reject makeup session proposal with ID: " + id, e);
        }
    }
    // AdministrateurServiceImpl.java
    @Override
    public PropositionDeRattrapageDTO approveScheduled(Long id, Long salleId) throws CustomException {
        try {
            // Validate inputs
            if (id == null || salleId == null) {
                throw new CustomException("Both proposal ID and room ID are required");
            }

            // Find existing makeup session proposal
            PropositionDeRattrapage proposition = propositionDeRattrapageRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Makeup session proposal not found with ID: " + id));

            // Validate current status
            if (proposition.getStatus() != Status.SCHEDULED) {
                throw new CustomException("Can only approve SCHEDULED makeup sessions");
            }

            // Find the room
            Salle salle = salleRepository.findById(salleId)
                    .orElseThrow(() -> new CustomException("Room not found with ID: " + salleId));

            // Create new Seance from proposition
            Seance newSeance = new Seance();
            newSeance.setName(proposition.getName());
            newSeance.setMatiere(proposition.getMatiere());
            newSeance.setType(proposition.getType());
            newSeance.setHeureDebut(proposition.getHeureDebut());
            newSeance.setHeureFin(proposition.getHeureFin());
            newSeance.setDate(proposition.getDate().toLocalDate());
            newSeance.setJour(proposition.getDate().getDayOfWeek());
            newSeance.setFrequence(FrequenceType.CATCHUP);
            newSeance.setSalle(salle);
            newSeance.setEnseignant(proposition.getEnseignant());
            newSeance.setBranches(new ArrayList<>(proposition.getBranches()));
            newSeance.setTds(new ArrayList<>(proposition.getTds()));
            newSeance.setTps(new ArrayList<>(proposition.getTps()));

            // Save the new Seance
            seanceRepository.save(newSeance);

            // Update proposition status
            proposition.setStatus(Status.APPROVED);
            PropositionDeRattrapage savedProposition = propositionDeRattrapageRepository.save(proposition);

            return entityMapper.toPropositionDeRattrapageDTO(savedProposition);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to approve scheduled makeup session with ID: " + id, e);
        }
    }

    @Override
    public PropositionDeRattrapageDTO rejectScheduled(Long id, String reason) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Proposal ID cannot be null");
            }

            if (reason == null || reason.trim().isEmpty()) {
                throw new CustomException("Rejection reason is required");
            }

            // Find existing makeup session proposal
            PropositionDeRattrapage proposition = propositionDeRattrapageRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Makeup session proposal not found with ID: " + id));

            // Validate current status
            if (proposition.getStatus() != Status.SCHEDULED) {
                throw new CustomException("Can only reject SCHEDULED makeup sessions");
            }

            // Update status and reason
            proposition.setStatus(Status.REJECTED);
            proposition.setReason(reason);
            PropositionDeRattrapage savedProposition = propositionDeRattrapageRepository.save(proposition);

            return entityMapper.toPropositionDeRattrapageDTO(savedProposition);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to reject scheduled makeup session with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.BrancheDTO;
import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Branche;
import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.repository.BrancheRepository;
import com.scheduling.universityschedule_backend.repository.TDRepository;
import com.scheduling.universityschedule_backend.service.BrancheService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for branch management.
 * Handles CRUD operations and branch-related functionalities.
 */
@Service
@Transactional
public class BrancheServiceImpl implements BrancheService {

    private final BrancheRepository brancheRepository;
    private final TDRepository tdRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public BrancheServiceImpl(BrancheRepository brancheRepository,
                              TDRepository tdRepository,
                              EntityMapper entityMapper) {
        this.brancheRepository = brancheRepository;
        this.tdRepository = tdRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public BrancheDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            // Retrieve branch
            Branche branche = brancheRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Branch not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toBrancheDTO(branche);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve branch with ID: " + id, e);
        }
    }

    @Override
    public List<BrancheDTO> findAll() throws CustomException {
        try {
            // Retrieve all branches
            List<Branche> branches = brancheRepository.findAll();

            // Convert to DTOs (no need to check if list is null - JPA returns empty list)
            return branches.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toBrancheDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all branches", e);
        }
    }

    @Override
    public BrancheDTO create(BrancheDTO brancheDTO) throws CustomException {
        try {
            // Validate input
            if (brancheDTO == null) {
                throw new CustomException("Branch data cannot be null");
            }

            // Check for duplicate ID if provided
            if (brancheDTO.getId() != null && brancheRepository.existsById(brancheDTO.getId())) {
                throw new CustomException("Branch with ID " + brancheDTO.getId() + " already exists");
            }

            // Convert to entity
            Branche branche = entityMapper.toBranche(brancheDTO);

            // Save entity
            Branche savedBranche = brancheRepository.save(branche);

            // Convert back to DTO
            return entityMapper.toBrancheDTO(savedBranche);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create branch", e);
        }
    }

    @Override
    public BrancheDTO update(Long id, BrancheDTO brancheDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            if (brancheDTO == null) {
                throw new CustomException("Branch data cannot be null");
            }

            // Find existing branch
            Branche existingBranche = brancheRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Branch not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(brancheDTO, existingBranche);

            // Save updated entity
            Branche updatedBranche = brancheRepository.save(existingBranche);

            // Convert back to DTO
            return entityMapper.toBrancheDTO(updatedBranche);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update branch with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            // Check if branch exists
            if (!brancheRepository.existsById(id)) {
                throw new CustomException("Branch not found with ID: " + id);
            }

            // Delete branch
            brancheRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete branch with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceDTO> getSchedule(Long branchId) throws CustomException {
        try {
            // Validate input
            if (branchId == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            // Find branch
            Branche branche = brancheRepository.findById(branchId)
                    .orElseThrow(() -> new CustomException("Branch not found with ID: " + branchId));

            // Get sessions from branch - handle null case properly
            List<Seance> seances = branche.getSeances();
            if (seances == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return seances.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve schedule for branch with ID: " + branchId, e);
        }
    }

    @Override
    public List<EtudiantDTO> getEtudiants(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            // Check if branch exists
            if (!brancheRepository.existsById(id)) {
                throw new CustomException("Branch not found with ID: " + id);
            }

            // Get students using TD repository
            List<Etudiant> etudiants = tdRepository.findAllEtudiantsByBrancheId(id);

            // JPA repositories typically return empty lists rather than null,
            // but we'll be defensive just in case
            if (etudiants == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return etudiants.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toEtudiantDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve students for branch with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.EnseignantDTO;
import com.scheduling.universityschedule_backend.dto.PropositionDeRattrapageDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.SignalDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.*;
import com.scheduling.universityschedule_backend.repository.EnseignantRepository;
import com.scheduling.universityschedule_backend.repository.PropositionDeRattrapageRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.repository.SignalRepository;
import com.scheduling.universityschedule_backend.service.EnseignantService;
import com.scheduling.universityschedule_backend.util.CustomLogger;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Service implementation for teacher operations.
 * Manages teacher schedules, teaching hours, and communication.
 */
@Service
@Transactional
public class EnseignantServiceImpl implements EnseignantService {

    private final EnseignantRepository enseignantRepository;
    private final SeanceRepository seanceRepository;
    private final EntityMapper entityMapper;
    private final PropositionDeRattrapageRepository propositionDeRattrapageRepository;
    private final SignalRepository signalRepository;

    /**
     * Constructor injection for dependencies
     */
    public EnseignantServiceImpl(EnseignantRepository enseignantRepository,
                                 SeanceRepository seanceRepository,
                                 EntityMapper entityMapper, PropositionDeRattrapageRepository propositionDeRattrapageRepository, SignalRepository signalRepository) {
        this.enseignantRepository = enseignantRepository;
        this.seanceRepository = seanceRepository;
        this.entityMapper = entityMapper;
        this.propositionDeRattrapageRepository = propositionDeRattrapageRepository;
        this.signalRepository = signalRepository;
    }

    @Override
    public EnseignantDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Retrieve teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toEnseignantDTO(enseignant);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve teacher with ID: " + id, e);
        }
    }

    @Override
    public List<EnseignantDTO> findAll() throws CustomException {
        try {
            // Retrieve all teachers
            List<Enseignant> enseignants = enseignantRepository.findAll();

            // Convert to DTOs
            return enseignants.stream()
                    .map(entityMapper::toEnseignantDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all teachers", e);
        }
    }

    @Override
    public EnseignantDTO create(EnseignantDTO enseignantDTO) throws CustomException {
        try {
            // Validate input
            if (enseignantDTO == null) {
                throw new CustomException("Teacher data cannot be null");
            }

            // Check for duplicate ID if provided
            if (enseignantDTO.getId() != null && enseignantRepository.existsById(enseignantDTO.getId())) {
                throw new CustomException("Teacher with ID " + enseignantDTO.getId() + " already exists");
            }

            // Convert to entity
            Enseignant enseignant = entityMapper.toEnseignant(enseignantDTO);

            // Save entity
            Enseignant savedEnseignant = enseignantRepository.save(enseignant);

            // Convert back to DTO
            return entityMapper.toEnseignantDTO(savedEnseignant);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create teacher", e);
        }
    }

    @Override
    public EnseignantDTO update(Long id, EnseignantDTO enseignantDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            if (enseignantDTO == null) {
                throw new CustomException("Teacher data cannot be null");
            }

            // Find existing teacher
            Enseignant existingEnseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(enseignantDTO, existingEnseignant);

            // Save updated entity
            Enseignant updatedEnseignant = enseignantRepository.save(existingEnseignant);

            // Convert back to DTO
            return entityMapper.toEnseignantDTO(updatedEnseignant);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update teacher with ID: " + id, e);
        }
    }

    @Override
    public EnseignantDTO delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Check if teacher exists
            if (!enseignantRepository.existsById(id)) {
                throw new CustomException("Teacher not found with ID: " + id);
            }
            EnseignantDTO returnedEnseignant = this.findById(id);
            // Delete teacher
            enseignantRepository.deleteById(id);
            enseignantRepository.flush();
            return returnedEnseignant;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete teacher with ID: " + id + e.getMessage(), e);
        }
    }

    @Override
    public List<SeanceDTO> getSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Find teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Get sessions from teacher - using safe access pattern for collections
            if (enseignant.getSeances() == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return enseignant.getSeances().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve schedule for teacher with ID: " + id, e);
        }
    }
    /**
     * Calculates total teaching hours for a teacher within a specific date range.
     * Weekly sessions count once per week, bi-weekly sessions count as half per week,
     * and makeup sessions with specific dates count only once if within range.
     *
     * @param teacherid Teacher's unique identifier
     * @param startdate Start date for calculation
     * @param enddate End date for calculation
     * @return Total hours taught between start and end date
     * @throws CustomException if calculation fails or dates are invalid
     */
    @Override
    public int getTotalTeachingHours(Long teacherid, LocalDate startdate, LocalDate enddate) throws CustomException {
        try {
            // Validate inputs
            if (teacherid == null || startdate == null || enddate == null) {
                throw new CustomException("Teacher ID and date range cannot be null");
            }

            if (startdate.isAfter(enddate)) {
                throw new CustomException("Start date must be before or equal to end date");
            }

            // Find teacher
            Enseignant enseignant = enseignantRepository.findById(teacherid)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + teacherid));

            // Get all sessions for the teacher
            List<Seance> sessions = enseignant.getSeances();
            if (sessions == null || sessions.isEmpty()) {
                return 0;
            }

            int totalHours = 0;

            // Process each session
            for (Seance seance : sessions) {
                if (seance == null || seance.getFrequence() == null) {
                    continue;
                }

                // Calculate session duration
                int sessionHours = getSessionHours(seance);
                if (sessionHours <= 0) continue;

                // Add hours based on session type
                switch (seance.getFrequence()) {
                    case WEEKLY:
                        totalHours += getWeeklyHours(seance, sessionHours, startdate, enddate);
                        break;

                    case BIWEEKLY:
                        totalHours += getBiweeklyHours(seance, sessionHours, startdate, enddate);
                        break;

                    case CATCHUP:
                        totalHours += getCatchupHours(seance, sessionHours, startdate, enddate);
                        break;
                }
            }

            return totalHours;

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to calculate teaching hours: " + e.getMessage(), e);
        }
    }

    /**
     * Calculates session duration in hours
     */
    private int getSessionHours(Seance seance) {
        try {
            LocalTime start = seance.getHeureDebut();
            LocalTime end = seance.getHeureFin();
            return (int) Math.ceil(Duration.between(start, end).toMinutes() / 60.0);
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * Calculates hours for weekly sessions
     */
    private int getWeeklyHours(Seance seance, int hours, LocalDate start, LocalDate end) {
        try {
            if (seance.getJour() == null) return 0;

            // Get total weeks when this session occurs
            DayOfWeek day = seance.getJour();
            long weeks = getWeeksWithDay(day, start, end);

            return (int) (weeks * hours);
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * Calculates hours for bi-weekly sessions
     */
    private int getBiweeklyHours(Seance seance, int hours, LocalDate start, LocalDate end) {
        int weeklyHours = getWeeklyHours(seance, hours, start, end);
        return (int) Math.ceil(weeklyHours / 2.0);
    }

    /**
     * Calculates hours for makeup sessions
     */
    private int getCatchupHours(Seance seance, int hours, LocalDate start, LocalDate end) {
        try {
            if (seance.getDate() == null ) return 0;

            LocalDate sessionDate = seance.getDate();
            return (!sessionDate.isBefore(start) && !sessionDate.isAfter(end)) ? hours : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    /**
     * Counts how many times a specific day of week occurs between two dates
     */
    private long getWeeksWithDay(DayOfWeek day, LocalDate start, LocalDate end) {
        // Adjust start date to first occurrence of the day
        LocalDate current = start;
        while (current.getDayOfWeek() != day) {
            current = current.plusDays(1);
            if (current.isAfter(end)) return 0;
        }

        // Count occurrences
        long count = 0;
        while (!current.isAfter(end)) {
            count++;
            current = current.plusWeeks(1);
        }

        return count;
    }
    /**
     * Submits makeup session request.
     * @param id Teacher's unique identifier
     * @param proposition Makeup session proposal DTO
     * @return Created makeup session proposal DTO
     * @throws CustomException if submission fails
     */
    @Override
    public PropositionDeRattrapageDTO submitMakeupRequest(Long id, PropositionDeRattrapageDTO proposition) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            if (proposition == null) {
                throw new CustomException("Makeup session proposal cannot be null");
            }

            // Find teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Convert DTO to entity
            PropositionDeRattrapage propositionEntity = entityMapper.toPropositionDeRattrapage(proposition);

            // Set submission date if not provided
            if (propositionEntity.getDate() == null) {
                propositionEntity.setDate(LocalDateTime.now());
            }

            // Set initial status
            propositionEntity.setStatus(Status.PENDING);

            // Associate proposal with teacher
            propositionEntity.setEnseignant(enseignant);

            // Save the proposition entity
            propositionDeRattrapageRepository.save(propositionEntity);

            // Convert back to DTO
            return entityMapper.toPropositionDeRattrapageDTO(propositionEntity);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to submit makeup session request for teacher with ID: " + id + e.getMessage());
        }
    }

    /**
     * Submits an issue or suggestion from a teacher.
     * @param id Teacher's unique identifier
     * @param signal Signal DTO containing issue or suggestion
     * @return Created signal DTO
     * @throws CustomException if submission fails
     */
    @Override
    public SignalDTO submitSignal(Long id, SignalDTO signal) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            if (signal == null) {
                throw new CustomException("Signal data cannot be null");
            }

            // Find teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Convert DTO to entity
            Signal signalEntity = entityMapper.toSignal(signal);

            // Set submission date if not provided
            if (signalEntity.getTimestamp() == null) {
                signalEntity.setTimestamp(LocalDateTime.now());
            }

            // Associate signal with teacher
            signalEntity.setEnseignant(enseignant);

            // Add signal to teacher's signals collection (if using bidirectional relationship)
            if (enseignant.getSignals() == null) {
                enseignant.setSignals(new ArrayList<>());
            }
            // Save teacher to persist the relationship
            signalRepository.save(signalEntity);

            // Convert back to DTO
            return entityMapper.toSignalDTO(signalEntity);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to submit signal for teacher with ID: " + id +'\n' + e.toString() );

        }
    }

    @Override
    public List<SignalDTO> getSignals(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Find teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Get signals from teacher - using safe access pattern for collections
            if (enseignant.getSignals() == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return enseignant.getSignals().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSignalDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve signals for teacher with ID: " + id, e);
        }
    }

    // EnseignantServiceImpl.java
    /**
     * Retrieves all subjects taught by a specific teacher.
     * @param id Teacher's unique identifier
     * @return List of subject names taught by the teacher
     * @throws CustomException if retrieval fails or teacher doesn't exist
     */
    @Override
    public List<String> getSubjects(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Find teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Get unique subjects from teacher's sessions
            if (enseignant.getSeances() == null) {
                return Collections.emptyList();
            }

            return enseignant.getSeances().stream()
                    .filter(Objects::nonNull)
                    .map(Seance::getMatiere)  // Get subject field from each session
                    .filter(Objects::nonNull)
                    .filter(matiere -> !matiere.trim().isEmpty())
                    .distinct()  // Remove duplicates
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve subjects for teacher with ID: " + id, e);
        }
    }

    /**
     * Retrieves all practical groups (TPs) taught by a specific teacher.
     * @param id Teacher's unique identifier
     * @return List of practical groups (TPs) taught by the teacher
     * @throws CustomException if retrieval fails or teacher doesn't exist
     */
    @Override
    public List<TPDTO> getStudentGroups(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Find teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Get sessions taught by this teacher
            List<Seance> teacherSeances = enseignant.getSeances();
            if (teacherSeances == null || teacherSeances.isEmpty()) {
                return Collections.emptyList();
            }

            // Extract unique TPs from sessions
            Set<TP> uniqueTPs = new HashSet<>();
            for (Seance seance : teacherSeances) {
                if (seance.getTps() != null) {
                    uniqueTPs.addAll(seance.getTps());
                }
            }

            // Convert to DTOs
            return uniqueTPs.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toTPDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve student groups for teacher with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.NotificationDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.model.TD;
import com.scheduling.universityschedule_backend.repository.EtudiantRepository;
import com.scheduling.universityschedule_backend.repository.NotificationRepository;
import com.scheduling.universityschedule_backend.service.EtudiantService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for student operations.
 * Handles CRUD operations and student-related functionalities.
 */
@Service
@Transactional
public class EtudiantServiceImpl implements EtudiantService {

    private final EtudiantRepository etudiantRepository;
    private final NotificationRepository notificationRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public EtudiantServiceImpl(EtudiantRepository etudiantRepository,
                               NotificationRepository notificationRepository,
                               EntityMapper entityMapper) {
        this.etudiantRepository = etudiantRepository;
        this.notificationRepository = notificationRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public EtudiantDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Retrieve student
            Etudiant etudiant = etudiantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Student not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toEtudiantDTO(etudiant);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve student with ID: " + id, e);
        }
    }

    @Override
    public List<EtudiantDTO> findAll() throws CustomException {
        try {
            // Retrieve all students
            List<Etudiant> etudiants = etudiantRepository.findAll();

            // Convert to DTOs (JPA repositories typically return empty lists rather than null)
            return etudiants.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toEtudiantDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all students", e);
        }
    }

    @Override
    public EtudiantDTO create(EtudiantDTO etudiantDTO) throws CustomException {
        try {
            // Validate input
            if (etudiantDTO == null) {
                throw new CustomException("Student data cannot be null");
            }

            // Check for duplicate ID if provided
            if (etudiantDTO.getId() != null && etudiantRepository.existsById(etudiantDTO.getId())) {
                throw new CustomException("Student with ID " + etudiantDTO.getId() + " already exists");
            }

            // Convert to entity
            Etudiant etudiant = entityMapper.toEtudiant(etudiantDTO);

            // Save entity
            Etudiant savedEtudiant = etudiantRepository.save(etudiant);

            // Convert back to DTO
            return entityMapper.toEtudiantDTO(savedEtudiant);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create student", e);
        }
    }

    @Override
    public EtudiantDTO update(Long id, EtudiantDTO etudiantDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            if (etudiantDTO == null) {
                throw new CustomException("Student data cannot be null");
            }

            // Find existing student
            Etudiant existingEtudiant = etudiantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Student not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(etudiantDTO, existingEtudiant);

            // Save updated entity
            Etudiant updatedEtudiant = etudiantRepository.save(existingEtudiant);

            // Convert back to DTO
            return entityMapper.toEtudiantDTO(updatedEtudiant);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update student with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Check if student exists
            if (!etudiantRepository.existsById(id)) {
                throw new CustomException("Student not found with ID: " + id);
            }

            // Delete student
            etudiantRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete student with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceDTO> getPersonalSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Find student
            Etudiant etudiant = etudiantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Student not found with ID: " + id));

            // Check if student is assigned to a practical group
            if (etudiant.getTp() == null) {
                throw new CustomException("Student with ID: " + id + " is not assigned to any practical group (TP)");
            }

            // Get sessions from TP
            if (etudiant.getTp().getSeances() == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return etudiant.getTp().getSeances().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve personal schedule for student with ID: " + id, e);
        }
    }

    // EtudiantServiceImpl.java
    /**
     * Retrieves schedule for a student's tutorial group (TD).
     * @param id Student's unique identifier
     * @return List of scheduled sessions for TD
     * @throws CustomException if schedule retrieval fails
     */
    @Override
    public List<SeanceDTO> getTDSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Find student
            Etudiant etudiant = etudiantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Student not found with ID: " + id));

            // Get student's TP
            if (etudiant.getTp() == null) {
                throw new CustomException("Student with ID: " + id + " is not assigned to any practical group (TP)");
            }

            // Get student's TD through TP
            TD td = etudiant.getTp().getTd();
            if (td == null) {
                throw new CustomException("Student's practical group is not associated with any tutorial group (TD)");
            }

            // Get TD sessions
            List<Seance> tdSessions = td.getSeances();
            if (tdSessions == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return tdSessions.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve TD schedule for student with ID: " + id, e);
        }
    }
    // EtudiantServiceImpl.java
    /**
     * Retrieves schedule for a specific branch.
     * @param id Student's unique identifier
     * @return List of scheduled sessions for branch
     * @throws CustomException if schedule retrieval fails
     */
    @Override
    public List<SeanceDTO> getBranchSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Find student
            Etudiant etudiant = etudiantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Student not found with ID: " + id));

            // Get student's branch
            if (etudiant.getBranche() == null) {
                throw new CustomException("Student with ID: " + id + " is not assigned to any branch");
            }

            // Get branch sessions
            List<Seance> branchSessions = etudiant.getBranche().getSeances();
            if (branchSessions == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return branchSessions.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve branch schedule for student with ID: " + id, e);
        }
    }

    @Override
    public List<NotificationDTO> getNotifications(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Check if student exists
            if (!etudiantRepository.existsById(id)) {
                throw new CustomException("Student not found with ID: " + id);
            }

            // Get notifications for student

            return notificationRepository.findAllByPersonneId(id).stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toNotificationDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve notifications for student with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.FichierExcelDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.FichierExcel;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.repository.FichierExcelRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.ExcelFileService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for Excel file operations.
 * Handles file uploads, processing, and history tracking.
 */
@Service
@Transactional
public class ExcelFileServiceImpl implements ExcelFileService {

    /**
     * File status constants
     */
    private static final String STATUS_PROCESSING = "Processing";
    private static final String STATUS_COMPLETED = "Completed";
    private static final String STATUS_FAILED = "Failed";

    private final FichierExcelRepository fichierExcelRepository;
    private final SeanceRepository seanceRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public ExcelFileServiceImpl(FichierExcelRepository fichierExcelRepository,
                                SeanceRepository seanceRepository,
                                EntityMapper entityMapper) {
        this.fichierExcelRepository = fichierExcelRepository;
        this.seanceRepository = seanceRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public FichierExcelDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("File ID cannot be null");
            }

            // Retrieve file
            FichierExcel fichierExcel = fichierExcelRepository.findById(id)
                    .orElseThrow(() -> new CustomException("File not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toFichierExcelDTO(fichierExcel);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve file with ID: " + id, e);
        }
    }

    @Override
    public List<FichierExcelDTO> findAll() throws CustomException {
        try {
            // Retrieve all files
            List<FichierExcel> fichiersExcel = fichierExcelRepository.findAll();

            // Convert to DTOs (JPA repositories typically return empty lists rather than null)
            return fichiersExcel.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toFichierExcelDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all files", e);
        }
    }

    @Override
    public FichierExcelDTO create(FichierExcelDTO fichierExcelDTO) throws CustomException {
        try {
            // Validate input
            if (fichierExcelDTO == null) {
                throw new CustomException("File data cannot be null");
            }

            // Check for duplicate ID if provided
            if (fichierExcelDTO.getId() != null && fichierExcelRepository.existsById(fichierExcelDTO.getId())) {
                throw new CustomException("File with ID " + fichierExcelDTO.getId() + " already exists");
            }

            // Convert to entity
            FichierExcel fichierExcel = entityMapper.toFichierExcel(fichierExcelDTO);

            // Save entity
            FichierExcel savedFichierExcel = fichierExcelRepository.save(fichierExcel);

            // Convert back to DTO
            return entityMapper.toFichierExcelDTO(savedFichierExcel);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create file", e);
        }
    }

    @Override
    public FichierExcelDTO update(Long id, FichierExcelDTO fichierExcelDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("File ID cannot be null");
            }

            if (fichierExcelDTO == null) {
                throw new CustomException("File data cannot be null");
            }

            // Find existing file
            FichierExcel existingFichierExcel = fichierExcelRepository.findById(id)
                    .orElseThrow(() -> new CustomException("File not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(fichierExcelDTO, existingFichierExcel);

            // Save updated entity
            FichierExcel updatedFichierExcel = fichierExcelRepository.save(existingFichierExcel);

            // Convert back to DTO
            return entityMapper.toFichierExcelDTO(updatedFichierExcel);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update file with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("File ID cannot be null");
            }

            // Check if file exists
            if (!fichierExcelRepository.existsById(id)) {
                throw new CustomException("File not found with ID: " + id);
            }

            // Delete file
            fichierExcelRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete file with ID: " + id, e);
        }
    }

    @Override
    public void upload(FichierExcelDTO file, List<SeanceDTO> seanceDTOS) throws CustomException {
        FichierExcel fichierExcel = null;

        try {
            // Validate inputs
            if (file == null) {
                throw new CustomException("File data cannot be null");
            }

            if (seanceDTOS == null) {
                throw new CustomException("Sessions data cannot be null");
            }

            // Convert file to entity
            fichierExcel = entityMapper.toFichierExcel(file);

            // Set import date and initial status
            fichierExcel.setImportDate(LocalDateTime.now());
            fichierExcel.setStatus(STATUS_PROCESSING);

            // Save file with initial status
            fichierExcelRepository.save(fichierExcel);

            // Convert and save sessions
            List<Seance> seances = seanceDTOS.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeance)
                    .collect(Collectors.toList());

            seanceRepository.saveAll(seances);

            // Update file status to completed
            fichierExcel.setStatus(STATUS_COMPLETED);
            fichierExcelRepository.save(fichierExcel);
        } catch (Exception e) {
            // Update file status to failed if an error occurs
            if (fichierExcel != null) {
                try {
                    fichierExcel.setStatus(STATUS_FAILED);
                    fichierExcelRepository.save(fichierExcel);
                } catch (Exception saveException) {
                    // Log this exception but don't throw it, we want to throw the original exception
                    System.err.println("Failed to update file status to FAILED: " + saveException.getMessage());
                }
            }

            // Throw the original exception
            if (e instanceof CustomException) {
                throw (CustomException) e;
            } else {
                throw new CustomException("Failed to upload and process file", e);
            }
        }
    }

    @Override
    public List<FichierExcelDTO> getImportHistory() throws CustomException {
        try {
            // Reuse findAll method since they do the same thing
            return findAll();
        } catch (CustomException e) {
            // Just change the error message to be more specific to this operation
            throw new CustomException("Failed to retrieve import history", e.getCause());
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.*;
import com.scheduling.universityschedule_backend.repository.*;
import com.scheduling.universityschedule_backend.service.NotificationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for notification operations.
 * Handles notification creation, updates, and various distribution methods.
 */
@Service
@Transactional
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;
    private final EntityMapper entityMapper;
    @Autowired
    private PersonneRepository personneRepository;
    @Autowired
    private EtudiantRepository etudiantRepository;
    @Autowired
    private EnseignantRepository enseignantRepository;
    @Autowired
    private TDRepository tdRepository;

    /**
     * Constructor injection for dependencies
     */
    public NotificationServiceImpl(NotificationRepository notificationRepository,
                                   EntityMapper entityMapper) {
        this.notificationRepository = notificationRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public NotificationDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Notification ID cannot be null");
            }

            // Retrieve notification
            Notification notification = notificationRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Notification not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toNotificationDTO(notification);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve notification with ID: " + id, e);
        }
    }

    @Override
    public List<NotificationDTO> findAll() throws CustomException {
        try {
            // Retrieve all notifications
            List<Notification> notifications = notificationRepository.findAll();

            // Convert to DTOs (JPA repositories typically return empty lists rather than null)
            return notifications.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toNotificationDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all notifications", e);
        }
    }

    @Override
    public NotificationDTO create(NotificationDTO notificationDTO) throws CustomException {
        try {
            // Validate input
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            // Check for duplicate ID if provided
            if (notificationDTO.getId() != null && notificationRepository.existsById(notificationDTO.getId())) {
                throw new CustomException("Notification with ID " + notificationDTO.getId() + " already exists");
            }

            // Convert to entity
            Notification notification = entityMapper.toNotification(notificationDTO);

            // Save entity
            Notification savedNotification = notificationRepository.save(notification);

            // Convert back to DTO
            return entityMapper.toNotificationDTO(savedNotification);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create notification", e);
        }
    }

    @Override
    public NotificationDTO update(Long id, NotificationDTO notificationDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Notification ID cannot be null");
            }

            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            // Find existing notification
            Notification existingNotification = notificationRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Notification not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(notificationDTO, existingNotification);

            // Save updated entity
            Notification updatedNotification = notificationRepository.save(existingNotification);

            // Convert back to DTO
            return entityMapper.toNotificationDTO(updatedNotification);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update notification with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Notification ID cannot be null");
            }

            // Check if notification exists
            if (!notificationRepository.existsById(id)) {
                throw new CustomException("Notification not found with ID: " + id);
            }

            // Delete notification
            notificationRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete notification with ID: " + id, e);
        }
    }

    @Override
    public void markAsRead(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Notification ID cannot be null");
            }

            // Find notification
            Notification notification = notificationRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Notification not found with ID: " + id));

            // Check if already read (skip update if already marked as read)
            if (Boolean.TRUE.equals(notification.getIsread())) {
                return; // Already read, no need to update
            }

            // Mark as read
            notification.setIsread(true);

            // Save updated notification
            notificationRepository.save(notification);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to mark notification as read: " + id, e);
        }
    }
    @Override
    public List<NotificationDTO> getUnreadNotifications() throws CustomException {
        try {
            // Retrieve unread notifications
            List<Notification> unreadNotifications = notificationRepository.findByIsreadFalse();

            // Convert to DTOs (JPA repositories typically return empty lists rather than null)
            return unreadNotifications.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toNotificationDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve unread notifications", e);
        }
    }

    @Override
    public void broadcastNotification(NotificationDTO notificationDTO) throws CustomException {
        try {
            // Validate input
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            // Validate message content
            if (notificationDTO.getMessage() == null || notificationDTO.getMessage().trim().isEmpty()) {
                throw new CustomException("Notification message cannot be empty");
            }

            // Create base notification
            Notification baseNotification = entityMapper.toNotification(notificationDTO);
            baseNotification.setDate(LocalDateTime.now());
            baseNotification.setIsread(false);
            baseNotification.setType("BROADCAST");

            // Get all users (Personne entities) using repository
            List<Personne> allUsers = personneRepository.findAll();

            // Create and save individual notifications for each user
            List<Notification> notifications = allUsers.stream()
                    .filter(Objects::nonNull)
                    .map(user -> {
                        Notification notification = new Notification();
                        notification.setMessage(baseNotification.getMessage());
                        notification.setDate(baseNotification.getDate());
                        notification.setType(baseNotification.getType());
                        notification.setIsread(false);
                        notification.setRecepteur(user);
                        notification.setExpediteur(baseNotification.getExpediteur());
                        return notification;
                    })
                    .collect(Collectors.toList());

            // Save all notifications in batch
            notificationRepository.saveAll(notifications);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to broadcast notification: " + e.getMessage(), e);
        }
    }

    @Override
    public void sendNotificationToTeachers(NotificationDTO notificationDTO) throws CustomException {
        try {
            // Validate input
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            // Validate message content
            if (notificationDTO.getMessage() == null || notificationDTO.getMessage().trim().isEmpty()) {
                throw new CustomException("Notification message cannot be empty");
            }

            // Create base notification
            Notification baseNotification = entityMapper.toNotification(notificationDTO);
            baseNotification.setDate(LocalDateTime.now());
            baseNotification.setIsread(false);
            baseNotification.setType("TEACHER_BROADCAST");

            // Get all teachers using repository
            List<Enseignant> allTeachers = enseignantRepository.findAll();

            // Create and save individual notifications for each teacher
            List<Notification> notifications = allTeachers.stream()
                    .filter(Objects::nonNull)
                    .map(teacher -> {
                        Notification notification = new Notification();
                        notification.setMessage(baseNotification.getMessage());
                        notification.setDate(baseNotification.getDate());
                        notification.setType(baseNotification.getType());
                        notification.setIsread(false);
                        notification.setRecepteur(teacher);
                        notification.setExpediteur(baseNotification.getExpediteur());
                        return notification;
                    })
                    .collect(Collectors.toList());

            // Save all notifications in batch
            notificationRepository.saveAll(notifications);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to send notification to teachers: " + e.getMessage(), e);
        }
    }

    @Override
    public void sendNotificationToStudents(NotificationDTO notificationDTO) throws CustomException {
        try {
            // Validate input
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            // Validate message content
            if (notificationDTO.getMessage() == null || notificationDTO.getMessage().trim().isEmpty()) {
                throw new CustomException("Notification message cannot be empty");
            }

            // Create base notification
            Notification baseNotification = entityMapper.toNotification(notificationDTO);
            baseNotification.setDate(LocalDateTime.now());
            baseNotification.setIsread(false);
            baseNotification.setType("STUDENT_BROADCAST");

            // Get all students using repository
            List<Etudiant> allStudents = etudiantRepository.findAll();

            // Create and save individual notifications for each student
            List<Notification> notifications = allStudents.stream()
                    .filter(Objects::nonNull)
                    .map(student -> {
                        Notification notification = new Notification();
                        notification.setMessage(baseNotification.getMessage());
                        notification.setDate(baseNotification.getDate());
                        notification.setType(baseNotification.getType());
                        notification.setIsread(false);
                        notification.setRecepteur(student);
                        notification.setExpediteur(baseNotification.getExpediteur());
                        return notification;
                    })
                    .collect(Collectors.toList());

            // Save all notifications in batch
            notificationRepository.saveAll(notifications);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to send notification to students: " + e.getMessage(), e);
        }
    }
    @Override
    public void sendNotificationToBranches(NotificationDTO notificationDTO, List<BrancheDTO> brancheDTOS) throws CustomException {
        try {
            // Validate inputs
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            if (brancheDTOS == null || brancheDTOS.isEmpty()) {
                throw new CustomException("Branch list cannot be null or empty");
            }

            // Convert branch DTOs to entities
            List<Branche> branches = brancheDTOS.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toBranche)
                    .toList();

            // Create base notification
            Notification baseNotification = entityMapper.toNotification(notificationDTO);
            baseNotification.setDate(LocalDateTime.now());
            baseNotification.setIsread(false);
            baseNotification.setType("BRANCH_NOTIFICATION");

            // Get all students from these branches using repository
            List<Notification> notifications = new ArrayList<>();

            // For each branch, get its TDs and their students
            for (Branche branch : branches) {
                List<TD> tds = tdRepository.getAllTDbyBrancheId(branch.getId());
                for (TD td : tds) {
                    if (td.getTpList() != null) {
                        for (TP tp : td.getTpList()) {
                            if (tp.getEtudiants() != null) {
                                for (Etudiant student : tp.getEtudiants()) {
                                    Notification notification = new Notification();
                                    notification.setMessage(baseNotification.getMessage());
                                    notification.setDate(baseNotification.getDate());
                                    notification.setType(baseNotification.getType());
                                    notification.setIsread(false);
                                    notification.setRecepteur(student);
                                    notification.setExpediteur(baseNotification.getExpediteur());
                                    notifications.add(notification);
                                }
                            }
                        }
                    }
                }
            }

            // Save all notifications in batch
            notificationRepository.saveAll(notifications);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to send notifications to branches: " + e.getMessage(), e);
        }
    }

    @Override
    public void sendNotificationToBranche(NotificationDTO notificationDTO, BrancheDTO brancheDTO) throws CustomException {
        try {
            // Validate inputs
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            if (brancheDTO == null) {
                throw new CustomException("Branch data cannot be null");
            }

            // Convert branch DTO to entity
            Branche branch = entityMapper.toBranche(brancheDTO);

            // Create base notification
            Notification baseNotification = entityMapper.toNotification(notificationDTO);
            baseNotification.setDate(LocalDateTime.now());
            baseNotification.setIsread(false);
            baseNotification.setType("SINGLE_BRANCH_NOTIFICATION");

            // Get all students from this branch using repository
            List<TD> tds = tdRepository.getAllTDbyBrancheId(branch.getId());
            List<Notification> notifications = new ArrayList<>();

            // For each TD, get its TPs and their students
            for (TD td : tds) {
                if (td.getTpList() != null) {
                    for (TP tp : td.getTpList()) {
                        if (tp.getEtudiants() != null) {
                            for (Etudiant student : tp.getEtudiants()) {
                                Notification notification = new Notification();
                                notification.setMessage(baseNotification.getMessage());
                                notification.setDate(baseNotification.getDate());
                                notification.setType(baseNotification.getType());
                                notification.setIsread(false);
                                notification.setRecepteur(student);
                                notification.setExpediteur(baseNotification.getExpediteur());
                                notifications.add(notification);
                            }
                        }
                    }
                }
            }

            // Save all notifications in batch
            notificationRepository.saveAll(notifications);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to send notification to branch: " + e.getMessage(), e);
        }
    }

    @Override
    public void sendNotificationToTDs(NotificationDTO notificationDTO, List<TDDTO> tddtos) throws CustomException {
        try {
            // Validate inputs
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            if (tddtos == null || tddtos.isEmpty()) {
                throw new CustomException("Tutorial groups list cannot be null or empty");
            }

            // Convert TD DTOs to entities
            List<TD> tds = tddtos.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toTD)
                    .toList();

            // Create base notification
            Notification baseNotification = entityMapper.toNotification(notificationDTO);
            baseNotification.setDate(LocalDateTime.now());
            baseNotification.setIsread(false);
            baseNotification.setType("TD_GROUP_NOTIFICATION");

            List<Notification> notifications = new ArrayList<>();

            // For each TD, get its TPs and their students
            for (TD td : tds) {
                if (td.getTpList() != null) {
                    for (TP tp : td.getTpList()) {
                        if (tp.getEtudiants() != null) {
                            for (Etudiant student : tp.getEtudiants()) {
                                Notification notification = new Notification();
                                notification.setMessage(baseNotification.getMessage());
                                notification.setDate(baseNotification.getDate());
                                notification.setType(baseNotification.getType());
                                notification.setIsread(false);
                                notification.setRecepteur(student);
                                notification.setExpediteur(baseNotification.getExpediteur());
                                notifications.add(notification);
                            }
                        }
                    }
                }
            }

            // Save all notifications in batch
            notificationRepository.saveAll(notifications);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to send notifications to tutorial groups: " + e.getMessage(), e);
        }
    }

    @Override
    public void sendNotificationToTD(NotificationDTO notificationDTO, TDDTO tddto) throws CustomException {
        try {
            // Validate inputs
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            if (tddto == null) {
                throw new CustomException("Tutorial group data cannot be null");
            }

            // Convert TD DTO to entity
            TD td = entityMapper.toTD(tddto);

            // Create base notification
            Notification baseNotification = entityMapper.toNotification(notificationDTO);
            baseNotification.setDate(LocalDateTime.now());
            baseNotification.setIsread(false);
            baseNotification.setType("SINGLE_TD_NOTIFICATION");

            List<Notification> notifications = new ArrayList<>();

            // Get all students from TPs in this TD
            if (td.getTpList() != null) {
                for (TP tp : td.getTpList()) {
                    if (tp.getEtudiants() != null) {
                        for (Etudiant student : tp.getEtudiants()) {
                            Notification notification = new Notification();
                            notification.setMessage(baseNotification.getMessage());
                            notification.setDate(baseNotification.getDate());
                            notification.setType(baseNotification.getType());
                            notification.setIsread(false);
                            notification.setRecepteur(student);
                            notification.setExpediteur(baseNotification.getExpediteur());
                            notifications.add(notification);
                        }
                    }
                }
            }

            // Save all notifications in batch
            notificationRepository.saveAll(notifications);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to send notification to tutorial group: " + e.getMessage(), e);
        }
    }
    @Override
    public void sendNotificationToTPs(NotificationDTO notificationDTO, List<TPDTO> tpdtos) throws CustomException {
        try {
            // Validate inputs
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            if (tpdtos == null || tpdtos.isEmpty()) {
                throw new CustomException("Practical groups list cannot be null or empty");
            }

            // Convert TP DTOs to entities for processing
            List<TP> tps = tpdtos.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toTP)
                    .toList();

            // Create base notification
            Notification baseNotification = entityMapper.toNotification(notificationDTO);
            baseNotification.setDate(LocalDateTime.now());
            baseNotification.setIsread(false);
            baseNotification.setType("TP_GROUP_NOTIFICATION");

            List<Notification> notifications = new ArrayList<>();

            // For each TP, create notifications for its students
            for (TP tp : tps) {
                if (tp.getEtudiants() != null) {
                    for (Etudiant student : tp.getEtudiants()) {
                        Notification notification = new Notification();
                        notification.setMessage(baseNotification.getMessage());
                        notification.setDate(baseNotification.getDate());
                        notification.setType(baseNotification.getType());
                        notification.setIsread(false);
                        notification.setRecepteur(student);
                        notification.setExpediteur(baseNotification.getExpediteur());
                        notifications.add(notification);
                    }
                }
            }

            // Save all notifications in batch
            notificationRepository.saveAll(notifications);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to send notifications to practical groups: " + e.getMessage(), e);
        }
    }

    @Override
    public void sendNotificationToTP(NotificationDTO notificationDTO, TPDTO tpdto) throws CustomException {
        try {
            // Validate inputs
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            if (tpdto == null) {
                throw new CustomException("Practical group data cannot be null");
            }

            // Convert TP DTO to entity
            TP tp = entityMapper.toTP(tpdto);

            // Create base notification
            Notification baseNotification = entityMapper.toNotification(notificationDTO);
            baseNotification.setDate(LocalDateTime.now());
            baseNotification.setIsread(false);
            baseNotification.setType("SINGLE_TP_NOTIFICATION");

            List<Notification> notifications = new ArrayList<>();

            // Create notifications for all students in the TP
            if (tp.getEtudiants() != null) {
                for (Etudiant student : tp.getEtudiants()) {
                    Notification notification = new Notification();
                    notification.setMessage(baseNotification.getMessage());
                    notification.setDate(baseNotification.getDate());
                    notification.setType(baseNotification.getType());
                    notification.setIsread(false);
                    notification.setRecepteur(student);
                    notification.setExpediteur(baseNotification.getExpediteur());
                    notifications.add(notification);
                }
            }

            // Save all notifications in batch
            notificationRepository.saveAll(notifications);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to send notification to practical group: " + e.getMessage(), e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SalleDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Salle;
import com.scheduling.universityschedule_backend.repository.SalleRepository;
import com.scheduling.universityschedule_backend.service.SalleService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for room management.
 * Handles room creation, updates, and availability checking.
 */
@Service
@Transactional
public class SalleServiceImpl implements SalleService {

    private final SalleRepository salleRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public SalleServiceImpl(SalleRepository salleRepository,
                            EntityMapper entityMapper) {
        this.salleRepository = salleRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public SalleDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Room ID cannot be null");
            }

            // Retrieve room
            Salle salle = salleRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Room not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toSalleDTO(salle);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve room with ID: " + id, e);
        }
    }

    @Override
    public List<SalleDTO> findAll() throws CustomException {
        try {
            // Retrieve all rooms
            List<Salle> salles = salleRepository.findAll();

            // Convert to DTOs
            return salles.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSalleDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all rooms", e);
        }
    }

    @Override
    public SalleDTO create(SalleDTO salleDTO) throws CustomException {
        try {
            // Validate input
            if (salleDTO == null) {
                throw new CustomException("Room data cannot be null");
            }

            // Check for duplicate ID if provided
            if (salleDTO.getId() != null && salleRepository.existsById(salleDTO.getId())) {
                throw new CustomException("Room with ID " + salleDTO.getId() + " already exists");
            }

            // Convert to entity
            Salle salle = entityMapper.toSalle(salleDTO);

            // Save entity
            Salle savedSalle = salleRepository.save(salle);

            // Convert back to DTO
            return entityMapper.toSalleDTO(savedSalle);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create room", e);
        }
    }

    @Override
    public SalleDTO update(Long id, SalleDTO salleDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Room ID cannot be null");
            }

            if (salleDTO == null) {
                throw new CustomException("Room data cannot be null");
            }

            // Find existing room
            Salle existingSalle = salleRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Room not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(salleDTO, existingSalle);

            // Save updated entity
            Salle updatedSalle = salleRepository.save(existingSalle);

            // Convert back to DTO
            return entityMapper.toSalleDTO(updatedSalle);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update room with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Room ID cannot be null");
            }

            // Check if room exists
            if (!salleRepository.existsById(id)) {
                throw new CustomException("Room not found with ID: " + id);
            }

            // Delete room
            salleRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete room with ID: " + id, e);
        }
    }

    @Override
    public List<SalleDTO> getAvailableRooms(LocalDate date, DayOfWeek day, LocalTime startTime, LocalTime endTime) throws CustomException {
        try {
            // Input validation
            if (day == null) {
                throw new CustomException("Day of week cannot be null");
            }
            if (startTime == null || endTime == null) {
                throw new CustomException("Start time and end time cannot be null");
            }
            if (startTime.isAfter(endTime) || startTime.equals(endTime)) {
                throw new CustomException("Start time must be before end time");
            }

            // For catch-up sessions (which require a specific date)
            // the date parameter is optional for regular sessions

            // Use the repository's custom query method that already handles the logic efficiently
            List<Salle> availableRooms = salleRepository.findAvailableRooms(day, startTime, endTime, date);

            // Transform to DTOs
            return availableRooms.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSalleDTO)
                    .collect(Collectors.toList());

        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (DateTimeParseException e) {
            throw new CustomException("Invalid date/time format: " + e.getMessage(), e);
        } catch (Exception e) {
            throw new CustomException("Failed to find available rooms: " + e.getMessage(), e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.SeanceConflictDTO;
import com.scheduling.universityschedule_backend.dto.SeanceRoomConflictDTO;
import com.scheduling.universityschedule_backend.dto.SingleSeanceConflictDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.model.FrequenceType;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.SeanceService;
import com.scheduling.universityschedule_backend.util.CustomLogger;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for session operations.
 * Handles session creation, scheduling, conflict detection, and related operations.
 */
@Service
@Transactional
public class SeanceServiceImpl implements SeanceService {

    /**
     * Frequency type constants
     */
    private static final FrequenceType BIWEEKLY = FrequenceType.BIWEEKLY;
    private static final FrequenceType CATCHUP = FrequenceType.CATCHUP;
    private static final FrequenceType WEEKLY = FrequenceType.WEEKLY;

    private final SeanceRepository seanceRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public SeanceServiceImpl(SeanceRepository seanceRepository,
                             EntityMapper entityMapper) {
        this.seanceRepository = seanceRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public SeanceDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Session ID cannot be null");
            }

            // Retrieve session
            Seance seance = seanceRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Session not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toSeanceDTO(seance);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve session with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceDTO> findAll() throws CustomException {
        try {
            // Retrieve all sessions
            List<Seance> seances = seanceRepository.findAll();

            // Convert to DTOs
            return seances.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all sessions", e);
        }
    }

    @Override
    public SeanceDTO create(SeanceDTO seanceDTO) throws CustomException {
        try {
            // Validate input
            if (seanceDTO == null) {
                throw new CustomException("Session data cannot be null");
            }

            // Note: We're allowing creation even with conflicts as per instructions

            // Convert DTO to entity
            Seance seance = entityMapper.toSeance(seanceDTO);

            // Save entity
            Seance savedSeance = seanceRepository.save(seance);

            // Convert back to DTO
            return entityMapper.toSeanceDTO(savedSeance);
        } catch (DateTimeParseException e) {
            throw new CustomException("Invalid date/time format: " + e.getMessage(), e);
        } catch (Exception e) {
            throw new CustomException("Failed to create session: " + e.getMessage(), e);
        }
    }

    @Override
    public SeanceDTO update(Long id, SeanceDTO seanceDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Session ID cannot be null");
            }

            if (seanceDTO == null) {
                throw new CustomException("Session data cannot be null");
            }

            // Find existing session
            Seance existingSeance = seanceRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Session not found with ID: " + id));

            // Note: We're allowing updates even with conflicts as per instructions

            // Set ID in DTO to ensure we're updating the right entity
            seanceDTO.setId(id);

            // Update entity
            entityMapper.updateFromDto(seanceDTO, existingSeance);

            // Save updated entity
            Seance updatedSeance = seanceRepository.save(existingSeance);

            // Convert back to DTO
            return entityMapper.toSeanceDTO(updatedSeance);
        } catch (CustomException e) {
            throw e;
        } catch (DateTimeParseException e) {
            throw new CustomException("Invalid date/time format: " + e.getMessage(), e);
        } catch (Exception e) {
            throw new CustomException("Failed to update session with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Session ID cannot be null");
            }

            // Check if session exists
            if (!seanceRepository.existsById(id)) {
                throw new CustomException("Session not found with ID: " + id);
            }

            // Delete session
            seanceRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete session with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceConflictDTO> getAllConflicts() throws CustomException {
        try {
            // Directly call repository method to find all conflicts
            List<Object[]> conflicts = seanceRepository.findConflictingSeancePairs(BIWEEKLY, CATCHUP);

            // Map conflicts to DTOs
            return entityMapper.toSeanceConflictDTOList(conflicts);
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all session conflicts", e);
        }
    }

    @Override
    public List<SeanceRoomConflictDTO> getRoomConflicts() throws CustomException {
        try {
            // Directly call repository method to find room conflicts
            List<Object[]> conflicts = seanceRepository.findConflictingByRooms(BIWEEKLY, CATCHUP);

            // Map conflicts to DTOs
            return entityMapper.toSeanceRoomConflictDTOList(conflicts);
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve room conflicts", e);
        }
    }

    @Override
    public List<SingleSeanceConflictDTO> getConflictsForSession(Long seanceId) throws CustomException {
        try {
            // Validate input
            if (seanceId == null) {
                throw new CustomException("Session ID cannot be null");
            }

            // Directly call repository method to find conflicts for specific session
            List<Object[]> conflicts = seanceRepository.findRoomConflictsForSeanceById(seanceId, BIWEEKLY, CATCHUP);

            // Map conflicts to DTOs
            return entityMapper.toSingleSeanceConflictDTOList(conflicts);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve conflicts for session with ID: " + seanceId, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<SingleSeanceConflictDTO> getConflictsForSession(SeanceDTO seanceDTO) throws CustomException {
        try {

            // Validate input
            if (seanceDTO == null) {
                throw new CustomException("Session data cannot be null");
            }

            // Initialize variables with default values
            LocalTime startTime = null;
            LocalTime endTime = null;
            DayOfWeek dayOfWeek = null;
            FrequenceType frequenceType = FrequenceType.WEEKLY; // Default value
            LocalDate date = null;

            // Parse time with validation
            try {
                if (seanceDTO.getHeureDebut() != null) {
                    startTime = LocalTime.parse(seanceDTO.getHeureDebut());
                }
                if (seanceDTO.getHeureFin() != null) {
                    endTime = LocalTime.parse(seanceDTO.getHeureFin());
                }
            } catch (DateTimeParseException e) {
                throw new CustomException("Invalid time format: " + e.getMessage());
            }

            // Validate times
            if (startTime != null && endTime != null && endTime.isBefore(startTime)) {
                throw new CustomException("End time cannot be before start time");
            }

            // Parse day of week with validation
            if (seanceDTO.getJour() != null) {
                try {
                    dayOfWeek = DayOfWeek.valueOf(seanceDTO.getJour().toUpperCase());
                } catch (IllegalArgumentException e) {
                    throw new CustomException("Invalid day of week: " + seanceDTO.getJour());
                }
            }

            // Parse frequency type with validation
            if (seanceDTO.getFrequence() != null) {
                try {
                    frequenceType = FrequenceType.fromString(seanceDTO.getFrequence().toUpperCase());
                } catch (IllegalArgumentException e) {
                    throw new CustomException("Invalid frequency type: " + seanceDTO.getFrequence());
                }
            }

            // Parse date with validation
            if (seanceDTO.getDate() != null && !seanceDTO.getDate().isEmpty()) {
                try {
                    date = LocalDate.parse(seanceDTO.getDate());
                } catch (DateTimeParseException e) {
                    throw new CustomException("Invalid date format: " + e.getMessage());
                }
            }

            // Ensure at least one search criterion is provided
            if (startTime == null && endTime == null && dayOfWeek == null &&
                    seanceDTO.getSalleId() == null && seanceDTO.getEnseignantId() == null &&
                    (seanceDTO.getTpIds() == null || seanceDTO.getTpIds().isEmpty()) &&
                    (seanceDTO.getTdIds() == null || seanceDTO.getTdIds().isEmpty()) &&
                    (seanceDTO.getBrancheIds() == null || seanceDTO.getBrancheIds().isEmpty())) {
                throw new CustomException("At least one search criterion must be provided");
            }
            CustomLogger.logInfo("after checking"+ seanceDTO);

            // Call repository with validated data
            List<Object[]> conflicts = seanceRepository.findConflictsForSeance(
                    seanceDTO.getSalleId(),
                    seanceDTO.getEnseignantId(),
                    seanceDTO.getTpIds(),
                    seanceDTO.getTdIds(),
                    seanceDTO.getBrancheIds(),
                    dayOfWeek,
                    startTime,
                    endTime,
                    frequenceType,
                    date,
                    FrequenceType.BIWEEKLY,
                    FrequenceType.CATCHUP
            );

            // Debug logging with correct casting
            for (Object[] conflict : conflicts) {
                Seance conflictingSeance = (Seance) conflict[0];
                String conflictTypes = (String) conflict[1];
                CustomLogger.logInfo("Conflicting Seance ID: " + conflictingSeance.getId());
                CustomLogger.logInfo("Conflict Types: " + conflictTypes);
            }

            return entityMapper.toSingleSeanceConflictDTOList(conflicts);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to check for session conflicts: " + e.getMessage());
        }
    }
    
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.TDDTO;
import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.model.TD;
import com.scheduling.universityschedule_backend.repository.TDRepository;
import com.scheduling.universityschedule_backend.service.TDService;
import com.scheduling.universityschedule_backend.util.CustomLogger;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Service implementation for managing Tutorial Groups (TD).
 * Handles CRUD operations and related functionalities for TDs.
 */
@Service
@Transactional
public class TDServiceImpl implements TDService {

    private final TDRepository tdRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     *
     * @param tdRepository The repository for TD entities
     * @param entityMapper The mapper for converting between entities and DTOs
     */
    public TDServiceImpl(TDRepository tdRepository, EntityMapper entityMapper) {
        this.tdRepository = tdRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    @Transactional(readOnly = true)
    public List<TDDTO> findAll() throws CustomException {
        try {
            CustomLogger.logInfo("Fetching all tutorial groups");
            List<TD> tds = tdRepository.findAll();

            return tds.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toTDDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve all tutorial groups", e);
            throw new CustomException("Failed to retrieve all tutorial groups", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public TDDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching tutorial group with ID: " + id);
            TD td = tdRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Tutorial group not found with ID: " + id);
                        return new CustomException("Tutorial group not found with ID: " + id);
                    });

            return entityMapper.toTDDTO(td);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve tutorial group with ID: " + id, e);
            throw new CustomException("Failed to retrieve tutorial group with ID: " + id, e);
        }
    }

    @Override
    public TDDTO create(TDDTO tdDTO) throws CustomException {
        try {
            // Validate input
            if (tdDTO == null) {
                CustomLogger.logError("Tutorial group data cannot be null");
                throw new CustomException("Tutorial group data cannot be null");
            }

            // Check for duplicate ID if provided
            if (tdDTO.getId() != null && tdRepository.existsById(tdDTO.getId())) {
                CustomLogger.logError("Tutorial group with ID " + tdDTO.getId() + " already exists");
                throw new CustomException("Tutorial group with ID " + tdDTO.getId() + " already exists");
            }

            CustomLogger.logInfo("Creating new tutorial group");
            TD td = entityMapper.toTD(tdDTO);
            TD savedTD = tdRepository.save(td);

            CustomLogger.logInfo("Created tutorial group with ID: " + savedTD.getId());
            return entityMapper.toTDDTO(savedTD);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to create tutorial group", e);
            throw new CustomException("Failed to create tutorial group", e);
        }
    }

    @Override
    public TDDTO update(Long id, TDDTO tdDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            if (tdDTO == null) {
                CustomLogger.logError("Tutorial group data cannot be null");
                throw new CustomException("Tutorial group data cannot be null");
            }

            CustomLogger.logInfo("Updating tutorial group with ID: " + id);
            TD existingTD = tdRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Tutorial group not found with ID: " + id);
                        return new CustomException("Tutorial group not found with ID: " + id);
                    });

            // Set the ID in the DTO to ensure we're updating the correct entity
            tdDTO.setId(id);
            entityMapper.updateFromDto(tdDTO, existingTD);
            TD updatedTD = tdRepository.save(existingTD);

            CustomLogger.logInfo("Updated tutorial group with ID: " + id);
            return entityMapper.toTDDTO(updatedTD);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to update tutorial group with ID: " + id, e);
            throw new CustomException("Failed to update tutorial group with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Checking if tutorial group with ID: " + id + " exists");
            if (!tdRepository.existsById(id)) {
                CustomLogger.logError("Tutorial group not found with ID: " + id);
                throw new CustomException("Tutorial group not found with ID: " + id);
            }

            CustomLogger.logInfo("Deleting tutorial group with ID: " + id);
            tdRepository.deleteById(id);
            CustomLogger.logInfo("Deleted tutorial group with ID: " + id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to delete tutorial group with ID: " + id, e);
            throw new CustomException("Failed to delete tutorial group with ID: " + id, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<TPDTO> getTPs(Long tdId) throws CustomException {
        try {
            // Validate input
            if (tdId == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching practical groups for tutorial group with ID: " + tdId);
            TD td = tdRepository.findById(tdId)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Tutorial group not found with ID: " + tdId);
                        return new CustomException("Tutorial group not found with ID: " + tdId);
                    });

            // Safely handle potential null collection
            if (td.getTpList() == null) {
                CustomLogger.logInfo("No practical groups found for tutorial group with ID: " + tdId);
                return Collections.emptyList();
            }

            List<TPDTO> tpDTOs = td.getTpList().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toTPDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Found " + tpDTOs.size() + " practical groups for tutorial group with ID: " + tdId);
            return tpDTOs;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve practical groups for tutorial group with ID: " + tdId, e);
            throw new CustomException("Failed to retrieve practical groups for tutorial group with ID: " + tdId, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<SeanceDTO> generateSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Generating schedule for tutorial group with ID: " + id);
            TD td = tdRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Tutorial group not found with ID: " + id);
                        return new CustomException("Tutorial group not found with ID: " + id);
                    });

            // Safely handle potential null collection
            if (td.getSeances() == null) {
                CustomLogger.logInfo("No sessions found for tutorial group with ID: " + id);
                return Collections.emptyList();
            }

            List<SeanceDTO> sessionDTOs = td.getSeances().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Generated schedule with " + sessionDTOs.size() + " sessions for tutorial group with ID: " + id);
            return sessionDTOs;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to generate schedule for tutorial group with ID: " + id, e);
            throw new CustomException("Failed to generate schedule for tutorial group with ID: " + id, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<EtudiantDTO> getEtudiants(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching students for tutorial group with ID: " + id);
            List<EtudiantDTO> students;

            // Check if there's a custom repository method for this query
            try {
                // This uses the repository's custom method
                CustomLogger.logInfo("Using repository method to fetch students directly");
                students = tdRepository.findAllEtudiantsByTdId(id).stream()
                        .filter(Objects::nonNull)
                        .map(entityMapper::toEtudiantDTO)
                        .collect(Collectors.toList());
            } catch (Exception ex) {
                // Fallback to relationship navigation if custom method isn't available
                CustomLogger.logInfo("Falling back to relationship navigation to get students");
                TD td = tdRepository.findById(id)
                        .orElseThrow(() -> {
                            CustomLogger.logError("Tutorial group not found with ID: " + id);
                            return new CustomException("Tutorial group not found with ID: " + id);
                        });

                // Safely handle potential null collection
                if (td.getTpList() == null) {
                    CustomLogger.logInfo("No practical groups found for tutorial group with ID: " + id);
                    return Collections.emptyList();
                }

                students = td.getTpList().stream()
                        .filter(Objects::nonNull)
                        .flatMap(tp -> {
                            if (tp.getEtudiants() == null) {
                                return Stream.<Etudiant>empty();
                            }
                            return tp.getEtudiants().stream();
                        })
                        .filter(Objects::nonNull)
                        .map(entityMapper::toEtudiantDTO)
                        .collect(Collectors.toList());
            }

            CustomLogger.logInfo("Found " + students.size() + " students for tutorial group with ID: " + id);
            return students;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve students for tutorial group with ID: " + id, e);
            throw new CustomException("Failed to retrieve students for tutorial group with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.TechnicienDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Technicien;
import com.scheduling.universityschedule_backend.repository.TechnicienRepository;
import com.scheduling.universityschedule_backend.service.TechnicienService;
import com.scheduling.universityschedule_backend.util.CustomLogger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Implementation of TechnicienService interface.
 * Handles technician-related operations and resource management.
 *
 * @author Mahmoud-ABK
 * @version 1.0
 * @since 2025-05-04
 */
@Service
public class TechnicienServiceImpl implements TechnicienService {

    private final TechnicienRepository technicienRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     *
     * @param technicienRepository Repository for Technician entities
     * @param entityMapper Mapper for converting between entities and DTOs
     */
    @Autowired
    public TechnicienServiceImpl(TechnicienRepository technicienRepository, EntityMapper entityMapper) {
        this.technicienRepository = technicienRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    @Transactional(readOnly = true)
    public TechnicienDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Technician ID cannot be null");
                throw new CustomException("Technician ID cannot be null");
            }

            CustomLogger.logInfo("Fetching technician with ID: " + id);
            Technicien technicien = technicienRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Technician not found with ID: " + id);
                        return new CustomException("Technician not found with ID: " + id);
                    });

            return entityMapper.toTechnicienDTO(technicien);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve technician with ID: " + id, e);
            throw new CustomException("Failed to retrieve technician with ID: " + id, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<TechnicienDTO> findAll() throws CustomException {
        try {
            CustomLogger.logInfo("Fetching all technicians");
            List<Technicien> techniciens = technicienRepository.findAll();

            // Handle empty list case
            if (techniciens.isEmpty()) {
                CustomLogger.logInfo("No technicians found in the system");
                return Collections.emptyList();
            }

            List<TechnicienDTO> technicienDTOs = techniciens.stream()
                    .map(entityMapper::toTechnicienDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Found " + technicienDTOs.size() + " technicians");
            return technicienDTOs;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve all technicians", e);
            throw new CustomException("Failed to retrieve all technicians", e);
        }
    }

    @Override
    @Transactional
    public TechnicienDTO create(TechnicienDTO technicienDTO) throws CustomException {
        try {
            // Validate input
            if (technicienDTO == null) {
                CustomLogger.logError("Technician data cannot be null");
                throw new CustomException("Technician data cannot be null");
            }

            // Check for duplicate ID if provided
            if (technicienDTO.getId() != null && technicienRepository.existsById(technicienDTO.getId())) {
                CustomLogger.logError("Technician with ID " + technicienDTO.getId() + " already exists");
                throw new CustomException("Technician with ID " + technicienDTO.getId() + " already exists");
            }

            CustomLogger.logInfo("Creating new technician");
            Technicien technicien = entityMapper.toTechnicien(technicienDTO);
            Technicien savedTechnicien = technicienRepository.save(technicien);

            CustomLogger.logInfo("Created technician with ID: " + savedTechnicien.getId());
            return entityMapper.toTechnicienDTO(savedTechnicien);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to create technician", e);
            throw new CustomException("Failed to create technician", e);
        }
    }

    @Override
    @Transactional
    public TechnicienDTO update(Long id, TechnicienDTO technicienDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                CustomLogger.logError("Technician ID cannot be null");
                throw new CustomException("Technician ID cannot be null");
            }

            if (technicienDTO == null) {
                CustomLogger.logError("Technician data cannot be null");
                throw new CustomException("Technician data cannot be null");
            }

            CustomLogger.logInfo("Updating technician with ID: " + id);
            Technicien existingTechnicien = technicienRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Technician not found with ID: " + id);
                        return new CustomException("Technician not found with ID: " + id);
                    });

            // Set the ID in the DTO to ensure we're updating the correct entity
            technicienDTO.setId(id);
            entityMapper.updateFromDto(technicienDTO, existingTechnicien);
            Technicien updatedTechnicien = technicienRepository.save(existingTechnicien);

            CustomLogger.logInfo("Updated technician with ID: " + id);
            return entityMapper.toTechnicienDTO(updatedTechnicien);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to update technician with ID: " + id, e);
            throw new CustomException("Failed to update technician with ID: " + id, e);
        }
    }

    @Override
    @Transactional
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Technician ID cannot be null");
                throw new CustomException("Technician ID cannot be null");
            }

            CustomLogger.logInfo("Checking if technician with ID: " + id + " exists");
            if (!technicienRepository.existsById(id)) {
                CustomLogger.logError("Technician not found with ID: " + id);
                throw new CustomException("Technician not found with ID: " + id);
            }

            CustomLogger.logInfo("Deleting technician with ID: " + id);
            technicienRepository.deleteById(id);
            CustomLogger.logInfo("Deleted technician with ID: " + id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to delete technician with ID: " + id, e);
            throw new CustomException("Failed to delete technician with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.TP;
import com.scheduling.universityschedule_backend.repository.TPRepository;
import com.scheduling.universityschedule_backend.service.TPService;
import com.scheduling.universityschedule_backend.util.CustomLogger;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for managing Practical Groups (TP).
 * Handles CRUD operations and related functionalities for TPs.
 *
 * @author Mahmoud-ABK
 * @version 1.0
 * @since 2025-03-05
 */
@Service
@Transactional
public class TPServiceImpl implements TPService {

    private final TPRepository tpRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     *
     * @param tpRepository The repository for TP entities
     * @param entityMapper The mapper for converting between entities and DTOs
     */
    public TPServiceImpl(TPRepository tpRepository, EntityMapper entityMapper) {
        this.tpRepository = tpRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    @Transactional(readOnly = true)
    public List<TPDTO> findAll() throws CustomException {
        try {
            CustomLogger.logInfo("Fetching all practical groups");
            List<TP> tps = tpRepository.findAll();

            List<TPDTO> tpDTOs = tps.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toTPDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Found " + tpDTOs.size() + " practical groups");
            return tpDTOs;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve all practical groups", e);
            throw new CustomException("Failed to retrieve all practical groups", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public TPDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching practical group with ID: " + id);
            TP tp = tpRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Practical group not found with ID: " + id);
                        return new CustomException("Practical group not found with ID: " + id);
                    });

            return entityMapper.toTPDTO(tp);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve practical group with ID: " + id, e);
            throw new CustomException("Failed to retrieve practical group with ID: " + id, e);
        }
    }

    @Override
    public TPDTO create(TPDTO tpDTO) throws CustomException {
        try {
            // Validate input
            if (tpDTO == null) {
                CustomLogger.logError("Practical group data cannot be null");
                throw new CustomException("Practical group data cannot be null");
            }

            // Check for duplicate ID if provided
            if (tpDTO.getId() != null && tpRepository.existsById(tpDTO.getId())) {
                CustomLogger.logError("Practical group with ID " + tpDTO.getId() + " already exists");
                throw new CustomException("Practical group with ID " + tpDTO.getId() + " already exists");
            }

            CustomLogger.logInfo("Creating new practical group");
            TP tp = entityMapper.toTP(tpDTO);
            TP savedTP = tpRepository.save(tp);

            CustomLogger.logInfo("Created practical group with ID: " + savedTP.getId());
            return entityMapper.toTPDTO(savedTP);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to create practical group", e);
            throw new CustomException("Failed to create practical group", e);
        }
    }

    @Override
    public TPDTO update(Long id, TPDTO tpDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            if (tpDTO == null) {
                CustomLogger.logError("Practical group data cannot be null");
                throw new CustomException("Practical group data cannot be null");
            }

            CustomLogger.logInfo("Updating practical group with ID: " + id);
            TP existingTP = tpRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Practical group not found with ID: " + id);
                        return new CustomException("Practical group not found with ID: " + id);
                    });

            // Set the ID in the DTO to ensure we're updating the correct entity
            tpDTO.setId(id);
            entityMapper.updateFromDto(tpDTO, existingTP);
            TP updatedTP = tpRepository.save(existingTP);

            CustomLogger.logInfo("Updated practical group with ID: " + id);
            return entityMapper.toTPDTO(updatedTP);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to update practical group with ID: " + id, e);
            throw new CustomException("Failed to update practical group with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            CustomLogger.logInfo("Checking if practical group with ID: " + id + " exists");
            if (!tpRepository.existsById(id)) {
                CustomLogger.logError("Practical group not found with ID: " + id);
                throw new CustomException("Practical group not found with ID: " + id);
            }

            CustomLogger.logInfo("Deleting practical group with ID: " + id);
            tpRepository.deleteById(id);
            CustomLogger.logInfo("Deleted practical group with ID: " + id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to delete practical group with ID: " + id, e);
            throw new CustomException("Failed to delete practical group with ID: " + id, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<EtudiantDTO> getStudents(Long tpId) throws CustomException {
        CustomLogger.logInfo("Redirecting getStudents to getEtudiants method for practical group: " + tpId);
        return getEtudiants(tpId);
    }

    @Override
    @Transactional(readOnly = true)
    public List<SeanceDTO> generateSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            CustomLogger.logInfo("Generating schedule for practical group with ID: " + id);
            TP tp = tpRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Practical group not found with ID: " + id);
                        return new CustomException("Practical group not found with ID: " + id);
                    });

            // Safely handle potential null collection
            if (tp.getSeances() == null) {
                CustomLogger.logInfo("No sessions found for practical group with ID: " + id);
                return Collections.emptyList();
            }

            List<SeanceDTO> sessionDTOs = tp.getSeances().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Generated schedule with " + sessionDTOs.size() + " sessions for practical group with ID: " + id);
            return sessionDTOs;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to generate schedule for practical group with ID: " + id, e);
            throw new CustomException("Failed to generate schedule for practical group with ID: " + id, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<EtudiantDTO> getEtudiants(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching students for practical group with ID: " + id);
            TP tp = tpRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Practical group not found with ID: " + id);
                        return new CustomException("Practical group not found with ID: " + id);
                    });

            // Safely handle potential null collection
            if (tp.getEtudiants() == null) {
                CustomLogger.logInfo("No students found for practical group with ID: " + id);
                return Collections.emptyList();
            }

            List<EtudiantDTO> students = tp.getEtudiants().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toEtudiantDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Found " + students.size() + " students for practical group with ID: " + id);
            return students;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve students for practical group with ID: " + id, e);
            throw new CustomException("Failed to retrieve students for practical group with ID: " + id, e);
        }
    }


}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.*;
import com.scheduling.universityschedule_backend.model.enums.AuditAction;
import com.scheduling.universityschedule_backend.model.enums.UserRole;
import com.scheduling.universityschedule_backend.model.enums.UserStatus;
import com.scheduling.universityschedule_backend.repository.AuditLogRepository;
import com.scheduling.universityschedule_backend.repository.UserCredentialsRepository;
import com.scheduling.universityschedule_backend.service.*;
import lombok.SneakyThrows;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class UserManagementServiceImpl implements UserManagementService {

    private final UserCredentialsRepository userCredentialsRepository;
    private final AuditLogRepository auditLogRepository;
    private final PasswordEncoder passwordEncoder;
    private final AdministrateurService administrateurService;
    private final TechnicienService technicienService;
    private final EnseignantService enseignantService;
    private final EtudiantService etudiantService;
    private final EntityMapper entityMapper;

    public UserManagementServiceImpl(
            UserCredentialsRepository userCredentialsRepository,
            AuditLogRepository auditLogRepository,
            PasswordEncoder passwordEncoder,
            AdministrateurService administrateurService,
            TechnicienService technicienService,
            EnseignantService enseignantService,
            EtudiantService etudiantService,
            EntityMapper entityMapper) {
        this.userCredentialsRepository = userCredentialsRepository;
        this.auditLogRepository = auditLogRepository;
        this.passwordEncoder = passwordEncoder;
        this.administrateurService = administrateurService;
        this.technicienService = technicienService;
        this.enseignantService = enseignantService;
        this.etudiantService = etudiantService;
        this.entityMapper = entityMapper;
    }

    @Override
    @PreAuthorize("hasAuthority('ROLE_TECHNICIAN')")
    public UserDTO findById(Long id) throws CustomException {
        UserCredentials credentials = userCredentialsRepository.findById(id)
                .orElseThrow(() -> new CustomException("User not found with ID: " + id));
        return toUserDTO(credentials);
    }

    @SneakyThrows
    @Override
    @PreAuthorize("hasAuthority('ROLE_TECHNICIAN')")
    public List<UserDTO> findAll() throws CustomException {
        return userCredentialsRepository.findAll().stream()
                .map(this::toUserDTO)
                .collect(Collectors.toList());
    }

    @Override
    @PreAuthorize("hasAuthority('ROLE_TECHNICIAN')")
    @Transactional
    public UserDTO create(UserDTO userDTO) throws CustomException {
        if (userCredentialsRepository.existsByUsername(userDTO.getUsername())) {
            throw new CustomException("Username already exists: " + userDTO.getUsername());
        }

        UserCredentials credentials = new UserCredentials();
        credentials.setUsername(userDTO.getUsername());
        credentials.setPassword(passwordEncoder.encode(userDTO.getPassword()));
        credentials.setRole(userDTO.getRole());
        credentials.setStatus(userDTO.getStatus() != null ? userDTO.getStatus() : UserStatus.ACTIVE);

        // Create Personne entity based on role
        Personne personne = createPersonne(userDTO.getPersonneData(), userDTO.getRole());
        credentials.setPersonne(personne);

        userCredentialsRepository.save(credentials);

        auditLogRepository.save(AuditLog.builder()
                .userLogin(credentials.getUsername())
                .action(AuditAction.USER_CREATED.name())
                .entityType("UserCredentials")
                .entityId(credentials.getId())
                .details("Performed by technician: " + getCurrentUsername())
                .timestamp(LocalDateTime.now())
                .build());

        return toUserDTO(credentials);
    }

    @Override
    @PreAuthorize("hasAuthority('ROLE_TECHNICIAN')")
    @Transactional
    public UserDTO update(Long id, UserDTO userDTO) throws CustomException {
        UserCredentials credentials = userCredentialsRepository.findById(id)
                .orElseThrow(() -> new CustomException("User not found with ID: " + id));

        if (!credentials.getUsername().equals(userDTO.getUsername()) &&
                userCredentialsRepository.existsByUsername(userDTO.getUsername())) {
            throw new CustomException("Username already exists: " + userDTO.getUsername());
        }

        credentials.setUsername(userDTO.getUsername());
        if (userDTO.getPassword() != null && !userDTO.getPassword().isEmpty()) {
            credentials.setPassword(passwordEncoder.encode(userDTO.getPassword()));
            credentials.setLastPasswordChange(LocalDateTime.now());
        }
        credentials.setRole(userDTO.getRole());
        credentials.setStatus(userDTO.getStatus());

        // Update Personne entity based on role
        updatePersonne(credentials.getPersonne(), userDTO.getPersonneData(), userDTO.getRole());

        userCredentialsRepository.save(credentials);

        auditLogRepository.save(AuditLog.builder()
                .userLogin(credentials.getUsername())
                .action(AuditAction.USER_UPDATED.name())
                .entityType("UserCredentials")
                .entityId(credentials.getId())
                .details("Performed by technician: " + getCurrentUsername())
                .timestamp(LocalDateTime.now())
                .build());

        return toUserDTO(credentials);
    }

    @Override
    @PreAuthorize("hasAuthority('ROLE_TECHNICIAN')")
    @Transactional
    public void delete(Long id) throws CustomException {
        UserCredentials credentials = userCredentialsRepository.findById(id)
                .orElseThrow(() -> new CustomException("User not found with ID: " + id));

        // Delete Personne entity based on role
        deletePersonne(credentials.getPersonne(), credentials.getRole());

        userCredentialsRepository.delete(credentials);

        auditLogRepository.save(AuditLog.builder()
                .userLogin(credentials.getUsername())
                .action(AuditAction.USER_DELETED.name())
                .entityType("UserCredentials")
                .entityId(id)
                .details("Performed by technician: " + getCurrentUsername())
                .timestamp(LocalDateTime.now())
                .build());
    }

    @Override
    @PreAuthorize("hasAuthority('ROLE_TECHNICIAN')")
    public UserDTO findByPersonneId(Long personneId) throws CustomException {
        UserCredentials credentials = userCredentialsRepository.findByPersonneId(personneId)
                .orElseThrow(() -> new CustomException("User not found with Personne ID: " + personneId));
        return toUserDTO(credentials);
    }

    private UserDTO toUserDTO(UserCredentials credentials) throws CustomException {
        UserDTO userDTO = new UserDTO();
        userDTO.setId(credentials.getId());
        userDTO.setPersonneId(credentials.getPersonne().getId());
        userDTO.setUsername(credentials.getUsername());
        userDTO.setRole(credentials.getRole());
        userDTO.setStatus(credentials.getStatus());

        // Map Personne to appropriate DTO based on role
        Personne personne = credentials.getPersonne();
        switch (credentials.getRole()) {
            case ROLE_ADMIN:
                userDTO.setPersonneData(entityMapper.toAdministrateurDTO((Administrateur) personne));
                break;
            case ROLE_TECHNICIAN:
                userDTO.setPersonneData(entityMapper.toTechnicienDTO((Technicien) personne));
                break;
            case ROLE_TEACHER:
                userDTO.setPersonneData(entityMapper.toEnseignantDTO((Enseignant) personne));
                break;
            case ROLE_STUDENT:
                userDTO.setPersonneData(entityMapper.toEtudiantDTO((Etudiant) personne));
                break;
            default:
                throw new CustomException("Unsupported role: " + credentials.getRole());
        }

        return userDTO;
    }

    private Personne createPersonne(Object personneData, UserRole role) throws CustomException {
        switch (role) {
            case ROLE_ADMIN:
                AdministrateurDTO adminDTO = (AdministrateurDTO) personneData;
                Administrateur admin = entityMapper.toAdministrateur(adminDTO);
                administrateurService.create(adminDTO); // Assuming save persists via service
                return admin;
            case ROLE_TECHNICIAN:
                TechnicienDTO techDTO = (TechnicienDTO) personneData;
                Technicien technicien = entityMapper.toTechnicien(techDTO);
                technicienService.create(techDTO); // Assuming save persists via service
                return technicien;
            case ROLE_TEACHER:
                EnseignantDTO teacherDTO = (EnseignantDTO) personneData;
                Enseignant enseignant = entityMapper.toEnseignant(teacherDTO);
                enseignantService.create(teacherDTO); // Assuming save persists via service
                return enseignant;
            case ROLE_STUDENT:
                EtudiantDTO studentDTO = (EtudiantDTO) personneData;
                Etudiant etudiant = entityMapper.toEtudiant(studentDTO);
                etudiantService.create(studentDTO); // Assuming save persists via service
                return etudiant;
            default:
                throw new CustomException("Unsupported role: " + role);
        }
    }

    private void updatePersonne(Personne personne, Object personneData, UserRole role) throws CustomException {
        switch (role) {
            case ROLE_ADMIN:
                AdministrateurDTO adminDTO = (AdministrateurDTO) personneData;
                entityMapper.updateFromDto(adminDTO, (Administrateur) personne);
                administrateurService.update(personne.getId(), adminDTO);
                break;
            case ROLE_TECHNICIAN:
                TechnicienDTO techDTO = (TechnicienDTO) personneData;
                entityMapper.updateFromDto(techDTO, (Technicien) personne);
                technicienService.update(personne.getId(), techDTO);
                break;
            case ROLE_TEACHER:
                EnseignantDTO teacherDTO = (EnseignantDTO) personneData;
                entityMapper.updateFromDto(teacherDTO, (Enseignant) personne);
                enseignantService.update(personne.getId(), teacherDTO);
                break;
            case ROLE_STUDENT:
                EtudiantDTO studentDTO = (EtudiantDTO) personneData;
                entityMapper.updateFromDto(studentDTO, (Etudiant) personne);
                etudiantService.update(personne.getId(), studentDTO);
                break;
            default:
                throw new CustomException("Unsupported role: " + role);
        }
    }

    private void deletePersonne(Personne personne, UserRole role) throws CustomException {
        switch (role) {
            case ROLE_ADMIN:
                administrateurService.delete(personne.getId());
                break;
            case ROLE_TECHNICIAN:
                technicienService.delete(personne.getId());
                break;
            case ROLE_TEACHER:
                enseignantService.delete(personne.getId());
                break;
            case ROLE_STUDENT:
                etudiantService.delete(personne.getId());
                break;
            default:
                throw new CustomException("Unsupported role: " + role);
        }
    }

    private String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication != null ? authentication.getName() : "unknown";
    }
}