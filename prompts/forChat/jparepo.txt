**Note**: All of these repositories extend JPARepository
**Note**: A JPARepository has by default these basic CRUD functions:

// Save operations
<S extends T> S save(S entity);
<S extends T> List<S> saveAll(Iterable<S> entities);
<S extends T> S saveAndFlush(S entity);
<S extends T> List<S> saveAllAndFlush(Iterable<S> entities);
void flush();

// Retrieve operations
Optional<T> findById(ID id);
List<T> findAll();
List<T> findAll(Sort sort);
List<T> findAllById(Iterable<ID> ids);
Page<T> findAll(Pageable pageable);
T getById(ID id);
boolean existsById(ID id);
long count();

// Delete operations
void deleteById(ID id);
void delete(T entity);
void deleteAllById(Iterable<? extends ID> ids);
void deleteAll(Iterable<? extends T> entities);
void deleteAll();
void deleteInBatch(Iterable<T> entities);
void deleteAllInBatch();
void deleteAllByIdInBatch(Iterable<ID> ids);

// Example and query methods
<S extends T> long count(Example<S> example);
<S extends T> boolean exists(Example<S> example);

Here are JPA repositories:
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Administrateur;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface AdministrateurRepository extends JpaRepository<Administrateur, Long> {
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Branche;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface BrancheRepository extends JpaRepository<Branche, Long> {

}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Enseignant;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface EnseignantRepository extends JpaRepository<Enseignant, Long> {
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Etudiant;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface EtudiantRepository extends JpaRepository<Etudiant, Long> {
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.FichierExcel;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface FichierExcelRepository extends JpaRepository<FichierExcel, Long> {
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Notification;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, Long> {
    List<Notification> findByIsreadFalse();
    /**
     * Custom query to get all notifications for a specific Personne ID (destination).
     * @param personneId the ID of the Personne (destination)
     * @return List of notifications for the specified Personne ID
     */
    @Query("SELECT n FROM Notification n WHERE n.recepteur.id = :personneId")
    List<Notification> findAllByPersonneId(@Param("personneId") Long personneId);
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Personne;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PersonneRepository extends JpaRepository<Personne, Long> {
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.PropositionDeRattrapage;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PropositionDeRattrapageRepository extends JpaRepository<PropositionDeRattrapage, Long> {
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Salle;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;

@Repository
public interface SalleRepository extends JpaRepository<Salle, Long> {
    /**
     * Finds all rooms that are NOT occupied during the specified time slot.
     *
     * This query uses a NOT EXISTS subquery to exclude rooms that have sessions that
     * overlap with the requested time frame. The query accounts for:
     * 1. Day of week matching
     * 2. Time overlap checking
     * 3. Special handling for bi-weekly and catch-up sessions
     *
     * @param jour Day of week for the requested time slot
     * @param heureDebut Start time for the requested slot
     * @param heureFin End time for the requested slot
     * @param date Specific date for catch-up sessions (can be null)
     * @return List of available rooms during the specified time
     */
    @Query("""
        SELECT s FROM Salle s
        WHERE NOT EXISTS (
            SELECT 1 FROM Seance seance
            WHERE seance.salle = s
              AND seance.jour = :jour
              AND seance.heureDebut < :heureFin
              AND seance.heureFin > :heureDebut
              AND (
                  seance.frequence = 'WEEKLY' 
                  OR (
                      seance.frequence = 'CATCHUP' 
                      AND (:date IS NULL OR seance.date = :date)
                  )
              )
        )
        ORDER BY s.identifiant
    """)
    List<Salle> findAvailableRooms(
            @Param("jour") DayOfWeek jour,
            @Param("heureDebut") LocalTime heureDebut,
            @Param("heureFin") LocalTime heureFin,
            @Param("date") LocalDate date
    );
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.FrequenceType;
import com.scheduling.universityschedule_backend.model.Seance;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;

@Repository
public interface SeanceRepository extends JpaRepository<Seance, Long> {

    @Query("""
    SELECT 
       s1, 
       s2,
       CONCAT(
          CASE WHEN s1.salle.id = s2.salle.id THEN 'Room Conflict; ' ELSE '' END,
          CASE WHEN s1.enseignant.id = s2.enseignant.id THEN 'Teacher Conflict; ' ELSE '' END,
          CASE WHEN EXISTS (
             SELECT 1 FROM TP tp
             WHERE (
                   (tp MEMBER OF s1.tps)
                   OR EXISTS (SELECT 1 FROM s1.tds t1 WHERE t1 = tp.td)
                   OR EXISTS (
                         SELECT 1 FROM s1.branches b1 
                         WHERE b1 = tp.td.branche 
                           AND NOT EXISTS (SELECT 1 FROM s1.tds t2 WHERE t2.branche = b1)
                   )
             )
             AND (
                   (tp MEMBER OF s2.tps)
                   OR EXISTS (SELECT 1 FROM s2.tds t3 WHERE t3 = tp.td)
                   OR EXISTS (
                         SELECT 1 FROM s2.branches b2 
                         WHERE b2 = tp.td.branche 
                           AND NOT EXISTS (SELECT 1 FROM s2.tds t4 WHERE t4.branche = b2)
                   )
             )
          ) THEN 'Student Group Conflict; ' ELSE '' END,
          CASE WHEN s1.frequence = :biweekly AND s2.frequence = :biweekly THEN 'Bi-Weekly Conflict; ' ELSE '' END,
          CASE WHEN ((s1.frequence = :catchup AND s2.frequence = :biweekly)
                     OR (s1.frequence = :biweekly AND s2.frequence = :catchup))
               THEN 'Catch-Up Exception; ' ELSE '' END
       ) AS conflictTypes 
    FROM Seance s1
    JOIN Seance s2 ON s1.jour = s2.jour AND s1.id < s2.id
    WHERE 
         s1.heureDebut < s2.heureFin 
         AND s1.heureFin > s2.heureDebut
         AND (
              s1.salle.id = s2.salle.id
              OR s1.enseignant.id = s2.enseignant.id
              OR EXISTS (
                   SELECT 1 FROM TP tp
                   WHERE (
                         (tp MEMBER OF s1.tps)
                         OR EXISTS (SELECT 1 FROM s1.tds t1 WHERE t1 = tp.td)
                         OR EXISTS (
                               SELECT 1 FROM s1.branches b1 
                               WHERE b1 = tp.td.branche
                                 AND NOT EXISTS (SELECT 1 FROM s1.tds t2 WHERE t2.branche = b1)
                         )
                   )
                   AND (
                         (tp MEMBER OF s2.tps)
                         OR EXISTS (SELECT 1 FROM s2.tds t3 WHERE t3 = tp.td)
                         OR EXISTS (
                               SELECT 1 FROM s2.branches b2 
                               WHERE b2 = tp.td.branche
                                 AND NOT EXISTS (SELECT 1 FROM s2.tds t4 WHERE t4.branche = b2)
                         )
                   )
              )
         )
    """)
    List<Object[]> findConflictingSeancePairs(@Param("biweekly") FrequenceType biweekly,
                                              @Param("catchup") FrequenceType catchup);

    @Query("""
    SELECT 
       s1, 
       s2,
       'Room Conflict' AS conflictTypes
    FROM Seance s1
    JOIN Seance s2 ON s1.jour = s2.jour AND s1.id < s2.id
    WHERE 
       s1.salle.id = s2.salle.id
       AND s1.heureDebut < s2.heureFin
       AND s1.heureFin > s2.heureDebut
       AND NOT (
           s1.frequence = :biweekly AND s2.frequence = :biweekly
       )
       AND NOT (
           s1.frequence = :catchup AND s2.frequence = :catchup AND s1.date != s2.date
       )
       AND NOT (
           (s1.frequence = :catchup AND s2.frequence = :biweekly)
           OR (s1.frequence = :biweekly AND s2.frequence = :catchup)
       )
    """)
    List<Object[]> findConflictingByRooms(@Param("biweekly") FrequenceType biweekly,
                                          @Param("catchup") FrequenceType catchup);

    @Query("""
    SELECT 
       s,
       CONCAT(
          CASE WHEN s.salle.id = s_main.salle.id THEN 'Room Conflict; ' ELSE '' END,
          CASE WHEN s.enseignant.id = s_main.enseignant.id THEN 'Teacher Conflict; ' ELSE '' END,
          CASE WHEN EXISTS (
             SELECT 1 FROM TP tp
             WHERE (
                   (tp MEMBER OF s.tps)
                   OR EXISTS (SELECT 1 FROM s.tds t1 WHERE t1 = tp.td)
                   OR EXISTS (
                         SELECT 1 FROM s.branches b1 
                         WHERE b1 = tp.td.branche
                           AND NOT EXISTS (SELECT 1 FROM s.tds t2 WHERE t2.branche = b1)
                   )
             )
             AND (
                   (tp MEMBER OF s_main.tps)
                   OR EXISTS (SELECT 1 FROM s_main.tds t3 WHERE t3 = tp.td)
                   OR EXISTS (
                         SELECT 1 FROM s_main.branches b2 
                         WHERE b2 = tp.td.branche
                           AND NOT EXISTS (SELECT 1 FROM s_main.tds t4 WHERE t4.branche = b2)
                   )
             )
          ) THEN 'Student Group Conflict; ' ELSE '' END,
          CASE WHEN s.frequence = :biweekly AND s_main.frequence = :biweekly THEN 'Bi-Weekly Conflict; ' ELSE '' END,
          CASE WHEN ((s.frequence = :catchup AND s_main.frequence = :biweekly)
                     OR (s.frequence = :biweekly AND s_main.frequence = :catchup))
               THEN 'Catch-Up Exception; ' ELSE '' END
       ) AS conflictTypes
    FROM Seance s
    JOIN Seance s_main ON s_main.id = :seanceId
    WHERE 
         s.id <> s_main.id
         AND s.jour = s_main.jour
         AND s.heureDebut < s_main.heureFin
         AND s.heureFin > s_main.heureDebut
         AND (
             s.salle.id = s_main.salle.id
             OR s.enseignant.id = s_main.enseignant.id
             OR EXISTS (
                   SELECT 1 FROM TP tp
                   WHERE (
                         (tp MEMBER OF s.tps)
                         OR EXISTS (SELECT 1 FROM s.tds t1 WHERE t1 = tp.td)
                         OR EXISTS (
                               SELECT 1 FROM s.branches b1 
                               WHERE b1 = tp.td.branche
                                 AND NOT EXISTS (SELECT 1 FROM s.tds t2 WHERE t2.branche = b1)
                         )
                   )
                   AND (
                         (tp MEMBER OF s_main.tps)
                         OR EXISTS (SELECT 1 FROM s_main.tds t3 WHERE t3 = tp.td)
                         OR EXISTS (
                               SELECT 1 FROM s_main.branches b2 
                               WHERE b2 = tp.td.branche
                                 AND NOT EXISTS (SELECT 1 FROM s_main.tds t4 WHERE t4.branche = b2)
                         )
                   )
             )
         )
    """)
    List<Object[]> findRoomConflictsForSeanceById(@Param("seanceId") Long seanceId,
                                                  @Param("biweekly") FrequenceType biweekly,
                                                  @Param("catchup") FrequenceType catchup);
    @Query("""
SELECT s.id,
       CONCAT(
           CASE WHEN (:salleId IS NOT NULL AND s.salle.id = :salleId) 
                THEN 'Room Conflict; ' ELSE '' END,
           CASE WHEN (:enseignantId IS NOT NULL AND s.enseignant.id = :enseignantId)
                THEN 'Teacher Conflict; ' ELSE '' END,
           CASE WHEN EXISTS (
                SELECT tp FROM TP tp
                WHERE tp IN elements(s.tps)
                   OR tp.td IN elements(s.tds)
                   OR (tp.td.branche IN elements(s.branches) 
                       AND NOT EXISTS (
                          SELECT t2 FROM TD t2 WHERE t2.branche = tp.td.branche AND t2 IN elements(s.tds)
                       )
                   )
                   AND (
                       (:incomingTpIds IS NOT NULL AND tp.id IN :incomingTpIds)
                    OR (:incomingTdIds IS NOT NULL AND tp.td.id IN :incomingTdIds)
                    OR (:incomingBranchIds IS NOT NULL AND tp.td.branche.id IN :incomingBranchIds
                        AND NOT EXISTS (
                            SELECT td FROM TD td WHERE td.branche = tp.td.branche AND td.id IN :incomingTdIds
                        )
                    )
                   )
            ) THEN 'Student Group Conflict; ' ELSE '' END,
           CASE WHEN (s.frequence = :biweekly AND :frequence = :biweekly)
                THEN 'Bi-Weekly Conflict; ' ELSE '' END,
           CASE WHEN ((s.frequence = :catchup AND :frequence = :biweekly)
                      OR (s.frequence = :biweekly AND :frequence = :catchup))
                THEN 'Catch-Up Exception; ' ELSE '' END
       ) AS conflictTypes
FROM Seance s
WHERE s.jour = :jour
  AND s.heureDebut < :heureFin
  AND s.heureFin > :heureDebut
  AND (
        (:salleId IS NOT NULL AND s.salle.id = :salleId)
     OR (:enseignantId IS NOT NULL AND s.enseignant.id = :enseignantId)
     OR EXISTS (
          SELECT tp FROM TP tp
          WHERE tp IN elements(s.tps)
             OR tp.td IN elements(s.tds)
             OR (tp.td.branche IN elements(s.branches) 
                 AND NOT EXISTS (SELECT t2 FROM TD t2 WHERE t2.branche = tp.td.branche AND t2 IN elements(s.tds))
                )
             AND (
                 (:incomingTpIds IS NOT NULL AND tp.id IN :incomingTpIds)
              OR (:incomingTdIds IS NOT NULL AND tp.td.id IN :incomingTdIds)
              OR (:incomingBranchIds IS NOT NULL AND tp.td.branche.id IN :incomingBranchIds
                  AND NOT EXISTS (
                       SELECT td FROM TD td WHERE td.branche = tp.td.branche AND td.id IN :incomingTdIds
                  )
                )
             )
     )
  )
  AND NOT (
      (s.frequence = :biweekly AND :frequence = :biweekly)
      AND EXISTS (
          SELECT tp FROM TP tp
          WHERE tp IN elements(s.tps)
             OR tp.td IN elements(s.tds)
             OR (tp.td.branche IN elements(s.branches) 
                 AND NOT EXISTS (SELECT t2 FROM TD t2 WHERE t2.branche = tp.td.branche AND t2 IN elements(s.tds))
                )
             AND (
                 (:incomingTpIds IS NOT NULL AND tp.id IN :incomingTpIds)
              OR (:incomingTdIds IS NOT NULL AND tp.td.id IN :incomingTdIds)
              OR (:incomingBranchIds IS NOT NULL AND tp.td.branche.id IN :incomingBranchIds
                  AND NOT EXISTS (
                       SELECT td FROM TD td WHERE td.branche = tp.td.branche AND td.id IN :incomingTdIds
                  )
                )
             )
      )
  )
  AND NOT (
      s.frequence = :catchup AND :frequence = :catchup 
      AND s.date != :date
  )
  AND NOT (
      ((s.frequence = :catchup AND :frequence = :biweekly)
        OR (s.frequence = :biweekly AND :frequence = :catchup))
      AND EXISTS (
          SELECT tp FROM TP tp
          WHERE tp IN elements(s.tps)
             OR tp.td IN elements(s.tds)
             OR (tp.td.branche IN elements(s.branches) 
                 AND NOT EXISTS (SELECT t2 FROM TD t2 WHERE t2.branche = tp.td.branche AND t2 IN elements(s.tds))
                )
             AND (
                 (:incomingTpIds IS NOT NULL AND tp.id IN :incomingTpIds)
              OR (:incomingTdIds IS NOT NULL AND tp.td.id IN :incomingTdIds)
              OR (:incomingBranchIds IS NOT NULL AND tp.td.branche.id IN :incomingBranchIds
                  AND NOT EXISTS (
                       SELECT td FROM TD td WHERE td.branche = tp.td.branche AND td.id IN :incomingTdIds
                  )
                )
             )
      )
  )
""")
    List<Object[]> findConflictsForSeance(
            @Param("salleId") Long salleId,
            @Param("enseignantId") Long enseignantId,
            @Param("incomingTpIds") List<Long> incomingTpIds,
            @Param("incomingTdIds") List<Long> incomingTdIds,
            @Param("incomingBranchIds") List<Long> incomingBranchIds,
            @Param("jour") DayOfWeek jour,
            @Param("heureDebut") LocalTime heureDebut,
            @Param("heureFin") LocalTime heureFin,
            @Param("frequence") FrequenceType frequence,
            @Param("date") LocalDate date,
            @Param("biweekly") FrequenceType biweekly,
            @Param("catchup") FrequenceType catchup
    );


}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Signal;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface SignalRepository extends JpaRepository<Signal, Long> {
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.model.TD;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface TDRepository extends JpaRepository<TD, Long> {
    @Query("SELECT e FROM Etudiant e WHERE e.branche.id = :brancheId")
    List<Etudiant> findAllEtudiantsByBrancheId(@Param("brancheId") Long brancheId);

    @Query("SELECT e FROM Etudiant e WHERE e.tp.td.id = :tdId")
    List<Etudiant> findAllEtudiantsByTdId(@Param("tdId") Long tdId);

    @Query("SELECT td FROM TD td WHERE td.branche.id = :brancheId")
    List<TD> getAllTDbyBrancheId(@Param("brancheId") Long brancheId);

}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.Technicien;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TechnicienRepository extends JpaRepository<Technicien, Long> {
}
package com.scheduling.universityschedule_backend.repository;

import com.scheduling.universityschedule_backend.model.TP;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TPRepository extends JpaRepository<TP, Long> {
}
