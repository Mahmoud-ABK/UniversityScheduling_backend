package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.AdministrateurDTO;
import com.scheduling.universityschedule_backend.dto.PropositionDeRattrapageDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Administrateur;
import com.scheduling.universityschedule_backend.model.PropositionDeRattrapage;
import com.scheduling.universityschedule_backend.repository.AdministrateurRepository;
import com.scheduling.universityschedule_backend.repository.PropositionDeRattrapageRepository;
import com.scheduling.universityschedule_backend.service.AdministrateurService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class AdministrateurServiceImpl implements AdministrateurService {

    @Autowired
    private AdministrateurRepository administrateurRepository;

    @Autowired
    private PropositionDeRattrapageRepository propositionDeRattrapageRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public AdministrateurDTO findById(Long id) throws CustomException {
        Administrateur administrateur = administrateurRepository.findById(id)
                .orElseThrow(() -> new CustomException("Administrator not found with ID: " + id));
        return entityMapper.toAdministrateurDTO(administrateur);
    }

    @Override
    public List<AdministrateurDTO> findAll() throws CustomException {
        List<Administrateur> administrateurs = administrateurRepository.findAll();
        return administrateurs.stream()
                .map(entityMapper::toAdministrateurDTO)
                .collect(Collectors.toList());
    }

    @Override
    public AdministrateurDTO create(AdministrateurDTO administrateurDTO) throws CustomException {
        Administrateur administrateur = entityMapper.toAdministrateur(administrateurDTO);
        Administrateur savedAdministrateur = administrateurRepository.save(administrateur);
        return entityMapper.toAdministrateurDTO(savedAdministrateur);
    }

    @Override
    public AdministrateurDTO update(Long id, AdministrateurDTO administrateurDTO) throws CustomException {
        Administrateur existingAdministrateur = administrateurRepository.findById(id)
                .orElseThrow(() -> new CustomException("Administrator not found with ID: " + id));
        entityMapper.updateFromDto(administrateurDTO, existingAdministrateur);
        Administrateur updatedAdministrateur = administrateurRepository.save(existingAdministrateur);
        return entityMapper.toAdministrateurDTO(updatedAdministrateur);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!administrateurRepository.existsById(id)) {
            throw new CustomException("Administrator not found with ID: " + id);
        }
        administrateurRepository.deleteById(id);
    }

    @Override
    public List<PropositionDeRattrapageDTO> getAllMakeupSessions() throws CustomException {
        List<PropositionDeRattrapage> propositions = propositionDeRattrapageRepository.findAll();
        return propositions.stream()
                .map(entityMapper::toPropositionDeRattrapageDTO)
                .collect(Collectors.toList());
    }

    @Override
    public void approveMakeupSession(Long id) throws CustomException {
        PropositionDeRattrapage proposition = propositionDeRattrapageRepository.findById(id)
                .orElseThrow(() -> new CustomException("Makeup session proposal not found with ID: " + id));
        proposition.setStatus("approved");
        propositionDeRattrapageRepository.save(proposition);
    }

    @Override
    public void rejectMakeupSession(Long id) throws CustomException {
        PropositionDeRattrapage proposition = propositionDeRattrapageRepository.findById(id)
                .orElseThrow(() -> new CustomException("Makeup session proposal not found with ID: " + id));
        proposition.setStatus("rejected");
        propositionDeRattrapageRepository.save(proposition);
    }
}
package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.BrancheDTO;
import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Branche;
import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.repository.BrancheRepository;
import com.scheduling.universityschedule_backend.repository.TDRepository;
import com.scheduling.universityschedule_backend.service.BrancheService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class BrancheServiceImpl implements BrancheService {

    @Autowired
    private BrancheRepository brancheRepository;

    @Autowired
    private TDRepository tdRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public BrancheDTO findById(Long id) throws CustomException {
        Branche branche = brancheRepository.findById(id)
                .orElseThrow(() -> new CustomException("Branch not found with ID: " + id));
        return entityMapper.toBrancheDTO(branche);
    }

    @Override
    public List<BrancheDTO> findAll() throws CustomException {
        List<Branche> branches = brancheRepository.findAll();
        return branches.stream()
                .map(entityMapper::toBrancheDTO)
                .collect(Collectors.toList());
    }

    @Override
    public BrancheDTO create(BrancheDTO brancheDTO) throws CustomException {
        Branche branche = entityMapper.toBranche(brancheDTO);
        Branche savedBranche = brancheRepository.save(branche);
        return entityMapper.toBrancheDTO(savedBranche);
    }

    @Override
    public BrancheDTO update(Long id, BrancheDTO brancheDTO) throws CustomException {
        Branche existingBranche = brancheRepository.findById(id)
                .orElseThrow(() -> new CustomException("Branch not found with ID: " + id));
        entityMapper.updateFromDto(brancheDTO, existingBranche);
        Branche updatedBranche = brancheRepository.save(existingBranche);
        return entityMapper.toBrancheDTO(updatedBranche);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!brancheRepository.existsById(id)) {
            throw new CustomException("Branch not found with ID: " + id);
        }
        brancheRepository.deleteById(id);
    }

    @Override
    public List<SeanceDTO> getSchedule(Long branchId) throws CustomException {
        Branche branche = brancheRepository.findById(branchId)
                .orElseThrow(() -> new CustomException("Branch not found with ID: " + branchId));
        List<Seance> seances = branche.getSeances();
        return seances.stream()
                .map(entityMapper::toSeanceDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<EtudiantDTO> getEtudiants(Long id) throws CustomException {
        List<Etudiant> etudiants = tdRepository.findAllEtudiantsByBrancheId(id);
        return etudiants.stream()
                .map(entityMapper::toEtudiantDTO)
                .collect(Collectors.toList());
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.EnseignantDTO;
import com.scheduling.universityschedule_backend.dto.PropositionDeRattrapageDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.SignalDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Enseignant;
import com.scheduling.universityschedule_backend.repository.EnseignantRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.EnseignantService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class EnseignantServiceImpl implements EnseignantService {

    @Autowired
    private EnseignantRepository enseignantRepository;

    @Autowired
    private SeanceRepository seanceRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public EnseignantDTO findById(Long id) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));
        return entityMapper.toEnseignantDTO(enseignant);
    }

    @Override
    public List<EnseignantDTO> findAll() throws CustomException {
        List<Enseignant> enseignants = enseignantRepository.findAll();
        return enseignants.stream()
                .map(entityMapper::toEnseignantDTO)
                .collect(Collectors.toList());
    }

    @Override
    public EnseignantDTO create(EnseignantDTO enseignantDTO) throws CustomException {
        Enseignant enseignant = entityMapper.toEnseignant(enseignantDTO);
        Enseignant savedEnseignant = enseignantRepository.save(enseignant);
        return entityMapper.toEnseignantDTO(savedEnseignant);
    }

    @Override
    public EnseignantDTO update(Long id, EnseignantDTO enseignantDTO) throws CustomException {
        Enseignant existingEnseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));
        entityMapper.updateFromDto(enseignantDTO, existingEnseignant);
        Enseignant updatedEnseignant = enseignantRepository.save(existingEnseignant);
        return entityMapper.toEnseignantDTO(updatedEnseignant);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!enseignantRepository.existsById(id)) {
            throw new CustomException("Teacher not found with ID: " + id);
        }
        enseignantRepository.deleteById(id);
    }

    @Override
    public List<SeanceDTO> getSchedule(Long id) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));
        return enseignant.getSeances().stream()
                .map(entityMapper::toSeanceDTO)
                .collect(Collectors.toList());
    }

    @Override
    public int getTotalTeachingHours(Long teacherId, LocalDate startDate, LocalDate endDate) throws CustomException {
        // Implement the logic to calculate total teaching hours
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public PropositionDeRattrapageDTO submitMakeupRequest(Long id, PropositionDeRattrapageDTO proposition) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));
        // Implement the logic to submit a makeup session request
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public SignalDTO submitSignal(Long id, SignalDTO signal) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));
        // Implement the logic to submit a signal
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public List<SignalDTO> getSignals(Long id) throws CustomException {
        Enseignant enseignant = enseignantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));
        return enseignant.getSignals().stream()
                .map(entityMapper::toSignalDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<String> getSubjects(Long id) throws CustomException {
        // Implement the logic to get all subjects taught by the teacher
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public List<TPDTO> getStudentGroups(Long id) throws CustomException {
        // Implement the logic to get all student groups taught by the teacher
        throw new UnsupportedOperationException("Method not implemented yet");
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.NotificationDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.repository.EtudiantRepository;
import com.scheduling.universityschedule_backend.repository.NotificationRepository;
import com.scheduling.universityschedule_backend.service.EtudiantService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class EtudiantServiceImpl implements EtudiantService {

    @Autowired
    private EtudiantRepository etudiantRepository;

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public EtudiantDTO findById(Long id) throws CustomException {
        Etudiant etudiant = etudiantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Student not found with ID: " + id));
        return entityMapper.toEtudiantDTO(etudiant);
    }

    @Override
    public List<EtudiantDTO> findAll() throws CustomException {
        List<Etudiant> etudiants = etudiantRepository.findAll();
        return etudiants.stream()
                .map(entityMapper::toEtudiantDTO)
                .collect(Collectors.toList());
    }

    @Override
    public EtudiantDTO create(EtudiantDTO etudiantDTO) throws CustomException {
        Etudiant etudiant = entityMapper.toEtudiant(etudiantDTO);
        Etudiant savedEtudiant = etudiantRepository.save(etudiant);
        return entityMapper.toEtudiantDTO(savedEtudiant);
    }

    @Override
    public EtudiantDTO update(Long id, EtudiantDTO etudiantDTO) throws CustomException {
        Etudiant existingEtudiant = etudiantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Student not found with ID: " + id));
        entityMapper.updateFromDto(etudiantDTO, existingEtudiant);
        Etudiant updatedEtudiant = etudiantRepository.save(existingEtudiant);
        return entityMapper.toEtudiantDTO(updatedEtudiant);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!etudiantRepository.existsById(id)) {
            throw new CustomException("Student not found with ID: " + id);
        }
        etudiantRepository.deleteById(id);
    }

    @Override
    public List<SeanceDTO> getPersonalSchedule(Long id) throws CustomException {
        Etudiant etudiant = etudiantRepository.findById(id)
                .orElseThrow(() -> new CustomException("Student not found with ID: " + id));
        return etudiant.getTp().getSeances().stream()
                .map(entityMapper::toSeanceDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<SeanceDTO> getBranchSchedule(Long brancheId) throws CustomException {
        // Implement the logic to retrieve the schedule for the specified branch
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public List<NotificationDTO> getNotifications(Long id) throws CustomException {
        if (!etudiantRepository.existsById(id)) {
            throw new CustomException("Student not found with ID: " + id);
        }
        return notificationRepository.findAllByPersonneId(id).stream()
                .map(entityMapper::toNotificationDTO)
                .collect(Collectors.toList());
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.FichierExcelDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.FichierExcel;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.repository.FichierExcelRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.ExcelFileService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class ExcelFileServiceImpl implements ExcelFileService {

    @Autowired
    private FichierExcelRepository fichierExcelRepository;

    @Autowired
    private SeanceRepository seanceRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public FichierExcelDTO findById(Long id) throws CustomException {
        FichierExcel fichierExcel = fichierExcelRepository.findById(id)
                .orElseThrow(() -> new CustomException("File not found with ID: " + id));
        return entityMapper.toFichierExcelDTO(fichierExcel);
    }

    @Override
    public List<FichierExcelDTO> findAll() throws CustomException {
        try {
            List<FichierExcel> fichiersExcel = fichierExcelRepository.findAll();
            return fichiersExcel.stream()
                    .map(entityMapper::toFichierExcelDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all files", e);
        }
    }

    @Override
    public FichierExcelDTO create(FichierExcelDTO fichierExcelDTO) throws CustomException {
        try {
            FichierExcel fichierExcel = entityMapper.toFichierExcel(fichierExcelDTO);
            FichierExcel savedFichierExcel = fichierExcelRepository.save(fichierExcel);
            return entityMapper.toFichierExcelDTO(savedFichierExcel);
        } catch (Exception e) {
            throw new CustomException("Failed to create file", e);
        }
    }

    @Override
    public FichierExcelDTO update(Long id, FichierExcelDTO fichierExcelDTO) throws CustomException {
        FichierExcel existingFichierExcel = fichierExcelRepository.findById(id)
                .orElseThrow(() -> new CustomException("File not found with ID: " + id));
        entityMapper.updateFromDto(fichierExcelDTO, existingFichierExcel);
        try {
            FichierExcel updatedFichierExcel = fichierExcelRepository.save(existingFichierExcel);
            return entityMapper.toFichierExcelDTO(updatedFichierExcel);
        } catch (Exception e) {
            throw new CustomException("Failed to update file", e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!fichierExcelRepository.existsById(id)) {
            throw new CustomException("File not found with ID: " + id);
        }
        try {
            fichierExcelRepository.deleteById(id);
        } catch (Exception e) {
            throw new CustomException("Failed to delete file", e);
        }
    }

    @Override
    public void upload(FichierExcelDTO file, List<SeanceDTO> seanceDTOS) throws CustomException {
        try {
            FichierExcel fichierExcel = entityMapper.toFichierExcel(file);
            fichierExcel.setImportDate(LocalDateTime.now());
            fichierExcel.setStatus("Processing");
            fichierExcelRepository.save(fichierExcel);

            List<Seance> seances = seanceDTOS.stream()
                    .map(entityMapper::toSeance)
                    .collect(Collectors.toList());
            seanceRepository.saveAll(seances);

            fichierExcel.setStatus("Completed");
            fichierExcelRepository.save(fichierExcel);
        } catch (Exception e) {
            throw new CustomException("Failed to upload and process file", e);
        }
    }

    @Override
    public List<FichierExcelDTO> getImportHistory() throws CustomException {
        try {
            List<FichierExcel> fichiersExcel = fichierExcelRepository.findAll();
            return fichiersExcel.stream()
                    .map(entityMapper::toFichierExcelDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve import history", e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Notification;
import com.scheduling.universityschedule_backend.repository.NotificationRepository;
import com.scheduling.universityschedule_backend.service.NotificationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class NotificationServiceImpl implements NotificationService {

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public NotificationDTO findById(Long id) throws CustomException {
        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new CustomException("Notification not found with ID: " + id));
        return entityMapper.toNotificationDTO(notification);
    }

    @Override
    public List<NotificationDTO> findAll() throws CustomException {
        List<Notification> notifications = notificationRepository.findAll();
        return notifications.stream()
                .map(entityMapper::toNotificationDTO)
                .collect(Collectors.toList());
    }

    @Override
    public NotificationDTO create(NotificationDTO notificationDTO) throws CustomException {
        Notification notification = entityMapper.toNotification(notificationDTO);
        Notification savedNotification = notificationRepository.save(notification);
        return entityMapper.toNotificationDTO(savedNotification);
    }

    @Override
    public NotificationDTO update(Long id, NotificationDTO notificationDTO) throws CustomException {
        Notification existingNotification = notificationRepository.findById(id)
                .orElseThrow(() -> new CustomException("Notification not found with ID: " + id));
        entityMapper.updateFromDto(notificationDTO, existingNotification);
        Notification updatedNotification = notificationRepository.save(existingNotification);
        return entityMapper.toNotificationDTO(updatedNotification);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!notificationRepository.existsById(id)) {
            throw new CustomException("Notification not found with ID: " + id);
        }
        notificationRepository.deleteById(id);
    }

    @Override
    public void markAsRead(Long id) throws CustomException {
        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new CustomException("Notification not found with ID: " + id));
        notification.setIsread(true);
        notificationRepository.save(notification);
    }

    @Override
    public List<NotificationDTO> getUnreadNotifications() throws CustomException {
        List<Notification> unreadNotifications = notificationRepository.findByIsreadFalse();
        return unreadNotifications.stream()
                .map(entityMapper::toNotificationDTO)
                .collect(Collectors.toList());
    }

    @Override
    public void broadcastNotification(NotificationDTO notificationDTO) throws CustomException {
        // Implement logic to send notification to all users (Teachers + Students not admins and Technicians)
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public void sendNotificationToTeachers(NotificationDTO notificationDTO) throws CustomException {
        // Implement logic to send notification to all teachers
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public void sendNotificationToStudents(NotificationDTO notificationDTO) throws CustomException {
        // Implement logic to send notification to all students
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public void sendNotificationToBranches(NotificationDTO notificationDTO, List<BrancheDTO> brancheDTOS) throws CustomException {
        // Implement logic to send notification to all branches
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public void sendNotificationToBranche(NotificationDTO notificationDTO, BrancheDTO brancheDTO) throws CustomException {
        // Implement logic to send notification to a specific branch
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public void sendNotificationToTDs(NotificationDTO notificationDTO, List<TDDTO> tddtos) throws CustomException {
        // Implement logic to send notification to tutorial groups
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public void sendNotificationToTD(NotificationDTO notificationDTO, TDDTO tddto) throws CustomException {
        // Implement logic to send notification to a specific tutorial group
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public void sendNotificationToTPs(NotificationDTO notificationDTO, List<TPDTO> tpdtos) throws CustomException {
        // Implement logic to send notification to practical sessions
        throw new UnsupportedOperationException("Method not implemented yet");
    }

    @Override
    public void sendNotificationToTP(NotificationDTO notificationDTO, TPDTO tpdto) throws CustomException {
        // Implement logic to send notification to a specific practical session
        throw new UnsupportedOperationException("Method not implemented yet");
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SalleDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.*;
import com.scheduling.universityschedule_backend.repository.SalleRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.SalleService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@Transactional
public class SalleServiceImpl implements SalleService {

    @Autowired
    private SalleRepository salleRepository;
    @Autowired
    private SeanceRepository seanceRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public SalleDTO findById(Long id) throws CustomException {
        Salle salle = salleRepository.findById(id)
                .orElseThrow(() -> new CustomException("Room not found with ID: " + id));
        return entityMapper.toSalleDTO(salle);
    }

    @Override
    public List<SalleDTO> findAll() throws CustomException {
        List<Salle> salles = salleRepository.findAll();
        return salles.stream()
                .map(entityMapper::toSalleDTO)
                .collect(Collectors.toList());
    }

    @Override
    public SalleDTO create(SalleDTO salleDTO) throws CustomException {
        Salle salle = entityMapper.toSalle(salleDTO);
        Salle savedSalle = salleRepository.save(salle);
        return entityMapper.toSalleDTO(savedSalle);
    }

    @Override
    public SalleDTO update(Long id, SalleDTO salleDTO) throws CustomException {
        Salle existingSalle = salleRepository.findById(id)
                .orElseThrow(() -> new CustomException("Room not found with ID: " + id));
        entityMapper.updateFromDto(salleDTO, existingSalle);
        Salle updatedSalle = salleRepository.save(existingSalle);
        return entityMapper.toSalleDTO(updatedSalle);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!salleRepository.existsById(id)) {
            throw new CustomException("Room not found with ID: " + id);
        }
        salleRepository.deleteById(id);
    }

    @Override
    public List<SalleDTO> getAvailableRooms(LocalDate date, DayOfWeek day, LocalTime startTime, LocalTime endTime) throws CustomException {
       try {
//            // 1. Get all rooms
//            List<Salle> allRooms = salleRepository.findAll();
//
//            // 2. Parse input times with formatters
//            DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm");
//            DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
//
//            LocalTime requestedStartTime = LocalTime.parse(startTime, timeFormatter);
//            LocalTime requestedEndTime = LocalTime.parse(endTime, timeFormatter);
//            LocalDate requestedDate = LocalDate.parse(date, dateFormatter);
//
//            // 3. Get all sessions that might conflict with the requested time slot
//            List<Seance> conflictingSeances = seanceRepository.findAll().stream()
//                    .filter(seance -> {
//                        // Filter by day of week
//                        if (seance.getJour() != null && seance.getJour().equalsIgnoreCase(day)) {
//                            try {
//                                // Parse seance times
//                                LocalTime seanceStartTime = LocalTime.parse(seance.getHeureDebut(), timeFormatter);
//                                LocalTime seanceEndTime = LocalTime.parse(seance.getHeureFin(), timeFormatter);
//
//                                // Check if times overlap
//                                boolean timesOverlap = isTimeOverlapping(requestedStartTime, requestedEndTime, seanceStartTime, seanceEndTime);
//
//                                if (!timesOverlap) {
//                                    return false; // No time overlap, no conflict
//                                }
//
//                                // Check frequency
//                                String frequency = seance.getFrequence();
//                                if (frequency == null || frequency.isEmpty() || frequency.equals("1/15")) {
//                                    // Weekly or default frequency - always conflicts on the same day
//                                    return true;
//                                } else {
//                                    // For specific dates, check if it's the requested date
//                                    // Attempting to parse frequency as a date - will throw exception if not valid
//                                    LocalDate sessionDate = LocalDate.parse(frequency, dateFormatter);
//                                    return requestedDate.equals(sessionDate);
//                                }
//                            } catch (DateTimeParseException e) {
//                                // Let the upper function handle this
//                                throw new RuntimeException("Error parsing date/time in seance ID: " +
//                                        seance.getId() + ": " + e.getMessage(), e);
//                            }
//                        }
//                        return false;
//                    })
//                    .toList();
//
//            // 4. Extract IDs of rooms that are occupied during the requested time slot
//            Set<Long> occupiedRoomIds = conflictingSeances.stream()
//                    .filter(seance -> seance.getSalle() != null)
//                    .map(seance -> seance.getSalle().getId())
//                    .collect(Collectors.toSet());
//
//            // 5. Filter out occupied rooms and get available ones
//            List<Salle> availableRooms = allRooms.stream()
//                    .filter(room -> !occupiedRoomIds.contains(room.getId()))
//                    .toList();
//
//            // 6. Convert to DTOs and return
//            return availableRooms.stream()
//                    .map(entityMapper::toSalleDTO)
//                    .collect(Collectors.toList());
        } catch (DateTimeParseException e) {
            // Convert to custom exception with clear message and rethrow
            throw new CustomException("Invalid date/time format: " + e.getMessage(), e);
        } catch (RuntimeException e) {
            // Capture and rethrow any runtime exceptions from the stream
            throw new CustomException("Error during room availability check: " + e.getMessage(), e);
        } catch (Exception e) {
            throw new CustomException("Failed to find available rooms: " + e.getMessage(), e);
        }
        return List.of();
    }

    /**
     * Helper method to determine if two time ranges overlap using Java's LocalTime
     *
     * @param start1 Start time of first range
     * @param end1   End time of first range
     * @param start2 Start time of second range
     * @param end2   End time of second range
     * @return true if the time ranges overlap
     */
    private boolean isTimeOverlapping(LocalTime start1, LocalTime end1, LocalTime start2, LocalTime end2) {
        return !start1.isAfter(end2) && !start2.isAfter(end1);
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceConflictDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.SeanceRoomConflictDTO;
import com.scheduling.universityschedule_backend.dto.SingleSeanceConflictDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.FrequenceType;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.SeanceService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class SeanceServiceImpl implements SeanceService {

    @Autowired
    private SeanceRepository seanceRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public List<SeanceDTO> findAll() throws CustomException {
        try {
            List<Seance> seances = seanceRepository.findAll();
            return seances.stream()
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all sessions", e);
        }
    }

    @Override
    public SeanceDTO findById(Long id) throws CustomException {
        Seance seance = seanceRepository.findById(id)
                .orElseThrow(() -> new CustomException("Session not found with ID: " + id));
        return entityMapper.toSeanceDTO(seance);
    }

    @Override
    public SeanceDTO create(SeanceDTO seanceDTO) throws CustomException {
        try {
            Seance seance = entityMapper.toSeance(seanceDTO);
            Seance savedSeance = seanceRepository.save(seance);
            return entityMapper.toSeanceDTO(savedSeance);
        } catch (Exception e) {
            throw new CustomException("Failed to create session", e);
        }
    }

    @Override
    public SeanceDTO update(Long id, SeanceDTO seanceDTO) throws CustomException {
        Seance existingSeance = seanceRepository.findById(id)
                .orElseThrow(() -> new CustomException("Session not found with ID: " + id));
        entityMapper.updateFromDto(seanceDTO, existingSeance);
        try {
            Seance updatedSeance = seanceRepository.save(existingSeance);
            return entityMapper.toSeanceDTO(updatedSeance);
        } catch (Exception e) {
            throw new CustomException("Failed to update session", e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!seanceRepository.existsById(id)) {
            throw new CustomException("Session not found with ID: " + id);
        }
        try {
            seanceRepository.deleteById(id);
        } catch (Exception e) {
            throw new CustomException("Failed to delete session", e);
        }
    }

    @Override
    public List<SeanceConflictDTO> getAllConflicts() throws CustomException {
        try {
            List<Object[]> conflicts = seanceRepository.findConflictingSeancePairs(FrequenceType.BIWEEKLY,FrequenceType.CATCHUP);
            return entityMapper.toSeanceConflictDTOList(conflicts);
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all session conflicts", e);
        }
    }

    @Override
    public List<SeanceRoomConflictDTO> getRoomConflicts() throws CustomException {
        try {
            List<Object[]> roomConflicts = seanceRepository.findConflictingByRooms(FrequenceType.BIWEEKLY,FrequenceType.CATCHUP);
            return entityMapper.toSeanceRoomConflictDTOList(roomConflicts);
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve room conflicts", e);
        }
    }

    @Override
    public List<SingleSeanceConflictDTO> getConflictsForSession(Long seanceId) throws CustomException {
        try {
            List<Object[]> conflicts = seanceRepository.findRoomConflictsForSeanceById(seanceId,FrequenceType.BIWEEKLY,FrequenceType.CATCHUP);
            return entityMapper.toSingleSeanceConflictDTOList(conflicts);
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve conflicts for session", e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.TDDTO;
import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.TD;
import com.scheduling.universityschedule_backend.repository.TDRepository;
import com.scheduling.universityschedule_backend.service.TDService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class TDServiceImpl implements TDService {

    @Autowired
    private TDRepository tdRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public List<TDDTO> findAll() throws CustomException {
        List<TD> tds = tdRepository.findAll();
        return tds.stream()
                .map(entityMapper::toTDDTO)
                .collect(Collectors.toList());
    }

    @Override
    public TDDTO findById(Long id) throws CustomException {
        TD td = tdRepository.findById(id)
                .orElseThrow(() -> new CustomException("Tutorial group not found with ID: " + id));
        return entityMapper.toTDDTO(td);
    }

    @Override
    public TDDTO create(TDDTO tdDTO) throws CustomException {
        TD td = entityMapper.toTD(tdDTO);
        TD savedTD = tdRepository.save(td);
        return entityMapper.toTDDTO(savedTD);
    }

    @Override
    public TDDTO update(Long id, TDDTO tdDTO) throws CustomException {
        TD existingTD = tdRepository.findById(id)
                .orElseThrow(() -> new CustomException("Tutorial group not found with ID: " + id));
        entityMapper.updateFromDto(tdDTO, existingTD);
        TD updatedTD = tdRepository.save(existingTD);
        return entityMapper.toTDDTO(updatedTD);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!tdRepository.existsById(id)) {
            throw new CustomException("Tutorial group not found with ID: " + id);
        }
        tdRepository.deleteById(id);
    }

    @Override
    public List<TPDTO> getTPs(Long tdId) throws CustomException {
        TD td = tdRepository.findById(tdId)
                .orElseThrow(() -> new CustomException("Tutorial group not found with ID: " + tdId));
        return td.getTpList().stream()
                .map(entityMapper::toTPDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<SeanceDTO> generateSchedule(Long id) throws CustomException {
        // Step 1: Retrieve the TD (Practical Session for TD) entity from the repository
        TD td = tdRepository.findById(id)
                .orElseThrow(() -> new CustomException("TD session not found with ID: " + id));

        // Step 2: Convert the list of Seance entities (associated with TD) to SeanceDTOs
        return td.getSeances().stream()
                .map(entityMapper::toSeanceDTO)  // Map each Seance entity to a SeanceDTO
                .collect(Collectors.toList());  // Collect the results into a List of SeanceDTOs
    }


    @Override
    public List<EtudiantDTO> getEtudiants(Long id) throws CustomException {
        TD td = tdRepository.findById(id)
                .orElseThrow(() -> new CustomException("Tutorial group not found with ID: " + id));
        return td.getTpList().stream()
                .flatMap(tp -> tp.getEtudiants().stream())
                .map(entityMapper::toEtudiantDTO)
                .collect(Collectors.toList());
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.TP;
import com.scheduling.universityschedule_backend.repository.TPRepository;
import com.scheduling.universityschedule_backend.service.TPService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class TPServiceImpl implements TPService {

    @Autowired
    private TPRepository tpRepository;

    @Autowired
    private EntityMapper entityMapper;

    @Override
    public List<TPDTO> findAll() throws CustomException {
        List<TP> tps = tpRepository.findAll();
        return tps.stream()
                .map(entityMapper::toTPDTO)
                .collect(Collectors.toList());
    }

    @Override
    public TPDTO findById(Long id) throws CustomException {
        TP tp = tpRepository.findById(id)
                .orElseThrow(() -> new CustomException("Practical session not found with ID: " + id));
        return entityMapper.toTPDTO(tp);
    }

    @Override
    public TPDTO create(TPDTO tpDTO) throws CustomException {
        TP tp = entityMapper.toTP(tpDTO);
        TP savedTP = tpRepository.save(tp);
        return entityMapper.toTPDTO(savedTP);
    }

    @Override
    public TPDTO update(Long id, TPDTO tpDTO) throws CustomException {
        TP existingTP = tpRepository.findById(id)
                .orElseThrow(() -> new CustomException("Practical session not found with ID: " + id));
        entityMapper.updateFromDto(tpDTO, existingTP);
        TP updatedTP = tpRepository.save(existingTP);
        return entityMapper.toTPDTO(updatedTP);
    }

    @Override
    public void delete(Long id) throws CustomException {
        if (!tpRepository.existsById(id)) {
            throw new CustomException("Practical session not found with ID: " + id);
        }
        tpRepository.deleteById(id);
    }

    @Override
    public List<EtudiantDTO> getStudents(Long tpId) throws CustomException {
        TP tp = tpRepository.findById(tpId)
                .orElseThrow(() -> new CustomException("Practical session not found with ID: " + tpId));
        return tp.getEtudiants().stream()
                .map(entityMapper::toEtudiantDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<SeanceDTO> generateSchedule(Long id) throws CustomException {
        // Implement the logic to generate the schedule for the given practical session

        // Step 1: Retrieve the TP (Practical Session) entity from the repository
        TP tp = tpRepository.findById(id)
                .orElseThrow(() -> new CustomException("Practical session not found with ID: " + id));

        // Step 2: Convert the list of Seance entities (associated with TP) to SeanceDTOs
        return tp.getSeances().stream()
                .map(entityMapper::toSeanceDTO)  // Map each Seance entity to a SeanceDTO
                .collect(Collectors.toList());  // Collect the results into a List of SeanceDTOs
    }


    @Override
    public List<EtudiantDTO> getEtudiants(Long id) throws CustomException {
        TP tp = tpRepository.findById(id)
                .orElseThrow(() -> new CustomException("Practical session not found with ID: " + id));
        return tp.getEtudiants().stream()
                .map(entityMapper::toEtudiantDTO)
                .collect(Collectors.toList());
    }
}