package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

@EqualsAndHashCode(callSuper = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "administrateurs")
@ToString(callSuper = true)
public class Administrateur extends Personne {
    private String codeAdmin;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.util.List;

@Entity
@Table(name = "branches", indexes = {
        @Index(name = "idx_branche_niveau_specialite", columnList = "niveau,specialite")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@NamedEntityGraph(
    name = "Branche.withSeances",
    attributeNodes = @NamedAttributeNode("seances")
)
@ToString(exclude = {"seances"})
public class Branche {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String niveau;
    private String specialite;
    private int nbTD;
    private String departement;

    @ManyToMany(mappedBy = "branches", fetch = FetchType.LAZY)
    private List<Seance> seances;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.util.List;

@Entity
@Table(name = "enseignants")
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@ToString(exclude = {"seances", "propositionsDeRattrapage", "signals"})
public class Enseignant extends Personne {
    private String codeEnseignant;
    private int heures;

    @OneToMany(mappedBy = "enseignant", fetch = FetchType.LAZY)
    private List<Seance> seances;

    @OneToMany(mappedBy = "enseignant", fetch = FetchType.LAZY)
    private List<PropositionDeRattrapage> propositionsDeRattrapage;

    @OneToMany(mappedBy = "enseignant", fetch = FetchType.LAZY)
    private List<Signal> signals;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity
@Table(name = "etudiants")
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@ToString(exclude = {"branche", "tp"})
public class Etudiant extends Personne {
    private String matricule;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branche_id")
    private Branche branche;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="tp_id")
    private TP tp;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "fichiers_excel")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FichierExcel {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String fileName;
    private String status;

    @ElementCollection
    private List<String> errors;

    private LocalDateTime importDate;
}
package com.scheduling.universityschedule_backend.model;

/**
 * Enum representing the frequency type of a session (Seance).
 * Used to indicate whether a session occurs weekly, biweekly, or is a makeup session.
 */
public enum FrequenceType {
    /**
     * Session occurs every week
     */
    WEEKLY,

    /**
     * Session occurs every other week (once per two weeks)
     */
    BIWEEKLY,

    /**
     * Session is a one-time makeup session
     */
    CATCHUP;

    /**
     * Convert a string representation to FrequenceType enum
     * @param value String value to convert
     * @return Corresponding FrequenceType or null if no match
     */
    public static FrequenceType fromString(String value) {
        if (value == null) {
            return null;
        }

        return switch (value.toLowerCase()) {
            case "weekly" -> WEEKLY;
            case "1/1" -> WEEKLY;
            case "biweekly" -> BIWEEKLY;
            case "1/15" -> BIWEEKLY;
            case "makeup", "catch-up"  -> CATCHUP;
            default -> null;
        };
    }

    /**
     * Convert FrequenceType to its string representation
     * @return String representation of frequency type
     */
    @Override
    public String toString() {
        return switch (this) {
            case WEEKLY -> "weekly";
            case BIWEEKLY -> "1/15";
            case CATCHUP -> "catch-up";
        };
    }
}package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.time.LocalDateTime;

@Entity
@Table(name = "notification", indexes = {
        @Index(name = "idx_notification_recepteur", columnList = "recepteur_id"),
        @Index(name = "idx_notification_date", columnList = "date"),
        @Index(name = "idx_notification_isread", columnList = "isread")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"recepteur", "expediteur"})
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String message;
    private LocalDateTime date;
    private String type;
    private Boolean isread;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "recepteur_id")
    private Personne recepteur;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "expediteur_id")
    private Personne expediteur;

    public boolean isRead() {
        return isread;
    }
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Personne {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String cin;
    private String nom;
    private String prenom;
    private String email;
    private String tel;
    private String adresse;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.time.LocalDateTime;

@Entity
@Table(name = "propositions_de_rattrapage")
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"enseignant"})
public class PropositionDeRattrapage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private LocalDateTime date;
    private String reason;
    private String status;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "enseignant_id")
    private Enseignant enseignant;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.util.List;

@Entity
@Table(name = "salles", indexes = {
        @Index(name = "idx_salle_identifiant", columnList = "identifiant"),
        @Index(name = "idx_salle_type", columnList = "type"),
        @Index(name = "idx_salle_capacite", columnList = "capacite")})
@Data
@NoArgsConstructor
@AllArgsConstructor
@NamedEntityGraph(
    name = "Salle.withSeances",
    attributeNodes = @NamedAttributeNode("seances")
)
@ToString(exclude = {"seances"})
public class Salle {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String identifiant;
    private String type;
    private int capacite;

    @OneToMany(mappedBy = "salle", fetch = FetchType.LAZY)
    private List<Seance> seances;



    @Override
    public String toString() {
        return "Salle{id=" + id +
                ", identifiant='" + identifiant + '\'' +
                ", type='" + type + '\'' +
                ", capacite=" + capacite +
                ", seancesCount=" + (seances != null ? seances.size() : "N/A") +
                '}';
    }
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.*;
import org.springframework.lang.Nullable;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "seances", indexes = {
        @Index(name = "idx_seance_jour", columnList = "jour"),
        @Index(name = "idx_seance_time_range", columnList = "heureDebut,heureFin"),
        @Index(name = "idx_seance_enseignant", columnList = "enseignant_id"),
        @Index(name = "idx_seance_salle", columnList = "salle_id"),
        @Index(name = "idx_seance_frequence", columnList = "frequence"),
        @Index(name = "idx_seance_date", columnList = "date")
})
@Getter @Setter @NoArgsConstructor @AllArgsConstructor
public class Seance {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String matiere;

    @Enumerated(EnumType.STRING)
    private DayOfWeek jour;

    private LocalTime heureDebut;
    private LocalTime heureFin;

    @Enumerated(EnumType.STRING)
    private FrequenceType frequence = FrequenceType.WEEKLY;

    // New field for makeup sessions
    @Nullable
    private LocalDate date;

    @ManyToOne
    @JoinColumn(name = "salle_id")
    private Salle salle;

    @ManyToOne
    @JoinColumn(name = "enseignant_id")
    private Enseignant enseignant;

    @ManyToMany
    @JoinTable(
            name = "seance_branche",
            joinColumns = @JoinColumn(name = "seance_id"),
            inverseJoinColumns = @JoinColumn(name = "branche_id")
    )
    private List<Branche> branches = new ArrayList<>();

    @ManyToMany
    @JoinTable(
            name = "seance_td",
            joinColumns = @JoinColumn(name = "seance_id"),
            inverseJoinColumns = @JoinColumn(name = "td_id")
    )
    private List<TD> tds = new ArrayList<>();

    @ManyToMany
    @JoinTable(
            name = "seance_tp",
            joinColumns = @JoinColumn(name = "seance_id"),
            inverseJoinColumns = @JoinColumn(name = "tp_id")
    )
    private List<TP> tps = new ArrayList<>();
}package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.time.LocalDateTime;

@Entity
@Table(name = "signals")
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"enseignant"})
public class Signal {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String message;
    private String severity;
    private LocalDateTime timestamp;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "enseignant_id")
    private Enseignant enseignant;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.util.List;

@Entity
@Table(name = "tds", indexes = {
        @Index(name = "idx_td_branche", columnList = "branche_id")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"tpList", "seances"})
public class TD {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int nb;
    private int nbTP;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branche_id")
    private Branche branche;

    @OneToMany(mappedBy = "td", fetch = FetchType.LAZY)
    private List<TP> tpList;

    @ManyToMany(mappedBy = "tds", fetch = FetchType.LAZY)
    private List<Seance> seances;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@EqualsAndHashCode(callSuper = true)
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "techniciens")
public class Technicien extends Personne {
    private String codeTechnicien;
}
package com.scheduling.universityschedule_backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import java.util.List;

@Entity
@Table(name = "tps", indexes = {
        @Index(name = "idx_tp_td", columnList = "td_id")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"etudiants", "seances"})
public class TP {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int nb;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "td_id")
    private TD td;

    @OneToMany(mappedBy = "tp", fetch = FetchType.LAZY)
    private List<Etudiant> etudiants;

    @ManyToMany(mappedBy = "tps", fetch = FetchType.LAZY)
    private List<Seance> seances;
}
