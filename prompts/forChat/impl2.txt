package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.*;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Notification;
import com.scheduling.universityschedule_backend.repository.NotificationRepository;
import com.scheduling.universityschedule_backend.service.NotificationService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for notification operations.
 * Handles notification creation, updates, and various distribution methods.
 */
@Service
@Transactional
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public NotificationServiceImpl(NotificationRepository notificationRepository,
                                   EntityMapper entityMapper) {
        this.notificationRepository = notificationRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public NotificationDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Notification ID cannot be null");
            }

            // Retrieve notification
            Notification notification = notificationRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Notification not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toNotificationDTO(notification);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve notification with ID: " + id, e);
        }
    }

    @Override
    public List<NotificationDTO> findAll() throws CustomException {
        try {
            // Retrieve all notifications
            List<Notification> notifications = notificationRepository.findAll();

            // Convert to DTOs (JPA repositories typically return empty lists rather than null)
            return notifications.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toNotificationDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all notifications", e);
        }
    }

    @Override
    public NotificationDTO create(NotificationDTO notificationDTO) throws CustomException {
        try {
            // Validate input
            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            // Check for duplicate ID if provided
            if (notificationDTO.getId() != null && notificationRepository.existsById(notificationDTO.getId())) {
                throw new CustomException("Notification with ID " + notificationDTO.getId() + " already exists");
            }

            // Convert to entity
            Notification notification = entityMapper.toNotification(notificationDTO);

            // Save entity
            Notification savedNotification = notificationRepository.save(notification);

            // Convert back to DTO
            return entityMapper.toNotificationDTO(savedNotification);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create notification", e);
        }
    }

    @Override
    public NotificationDTO update(Long id, NotificationDTO notificationDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Notification ID cannot be null");
            }

            if (notificationDTO == null) {
                throw new CustomException("Notification data cannot be null");
            }

            // Find existing notification
            Notification existingNotification = notificationRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Notification not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(notificationDTO, existingNotification);

            // Save updated entity
            Notification updatedNotification = notificationRepository.save(existingNotification);

            // Convert back to DTO
            return entityMapper.toNotificationDTO(updatedNotification);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update notification with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Notification ID cannot be null");
            }

            // Check if notification exists
            if (!notificationRepository.existsById(id)) {
                throw new CustomException("Notification not found with ID: " + id);
            }

            // Delete notification
            notificationRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete notification with ID: " + id, e);
        }
    }

    @Override
    public void markAsRead(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Notification ID cannot be null");
            }

            // Find notification
            Notification notification = notificationRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Notification not found with ID: " + id));

            // Check if already read (skip update if already marked as read)
            if (Boolean.TRUE.equals(notification.getIsread())) {
                return; // Already read, no need to update
            }

            // Mark as read
            notification.setIsread(true);

            // Save updated notification
            notificationRepository.save(notification);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to mark notification as read: " + id, e);
        }
    }

    @Override
    public List<NotificationDTO> getUnreadNotifications() throws CustomException {
        try {
            // Retrieve unread notifications
            List<Notification> unreadNotifications = notificationRepository.findByIsreadFalse();

            // Convert to DTOs (JPA repositories typically return empty lists rather than null)
            return unreadNotifications.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toNotificationDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve unread notifications", e);
        }
    }

    @Override
    public void broadcastNotification(NotificationDTO notificationDTO) throws CustomException {
        // Validate input
        if (notificationDTO == null) {
            throw new CustomException("Notification data cannot be null");
        }

        // For now, this method is unimplemented
        throw new CustomException("Method not implemented yet: broadcastNotification");
    }

    @Override
    public void sendNotificationToTeachers(NotificationDTO notificationDTO) throws CustomException {
        // Validate input
        if (notificationDTO == null) {
            throw new CustomException("Notification data cannot be null");
        }

        // For now, this method is unimplemented
        throw new CustomException("Method not implemented yet: sendNotificationToTeachers");
    }

    @Override
    public void sendNotificationToStudents(NotificationDTO notificationDTO) throws CustomException {
        // Validate input
        if (notificationDTO == null) {
            throw new CustomException("Notification data cannot be null");
        }

        // For now, this method is unimplemented
        throw new CustomException("Method not implemented yet: sendNotificationToStudents");
    }

    @Override
    public void sendNotificationToBranches(NotificationDTO notificationDTO, List<BrancheDTO> brancheDTOS) throws CustomException {
        // Validate inputs
        if (notificationDTO == null) {
            throw new CustomException("Notification data cannot be null");
        }

        if (brancheDTOS == null || brancheDTOS.isEmpty()) {
            throw new CustomException("Branch list cannot be null or empty");
        }

        // For now, this method is unimplemented
        throw new CustomException("Method not implemented yet: sendNotificationToBranches");
    }

    @Override
    public void sendNotificationToBranche(NotificationDTO notificationDTO, BrancheDTO brancheDTO) throws CustomException {
        // Validate inputs
        if (notificationDTO == null) {
            throw new CustomException("Notification data cannot be null");
        }

        if (brancheDTO == null) {
            throw new CustomException("Branch data cannot be null");
        }

        // For now, this method is unimplemented
        throw new CustomException("Method not implemented yet: sendNotificationToBranche");
    }

    @Override
    public void sendNotificationToTDs(NotificationDTO notificationDTO, List<TDDTO> tddtos) throws CustomException {
        // Validate inputs
        if (notificationDTO == null) {
            throw new CustomException("Notification data cannot be null");
        }

        if (tddtos == null || tddtos.isEmpty()) {
            throw new CustomException("Tutorial groups list cannot be null or empty");
        }

        // For now, this method is unimplemented
        throw new CustomException("Method not implemented yet: sendNotificationToTDs");
    }

    @Override
    public void sendNotificationToTD(NotificationDTO notificationDTO, TDDTO tddto) throws CustomException {
        // Validate inputs
        if (notificationDTO == null) {
            throw new CustomException("Notification data cannot be null");
        }

        if (tddto == null) {
            throw new CustomException("Tutorial group data cannot be null");
        }

        // For now, this method is unimplemented
        throw new CustomException("Method not implemented yet: sendNotificationToTD");
    }

    @Override
    public void sendNotificationToTPs(NotificationDTO notificationDTO, List<TPDTO> tpdtos) throws CustomException {
        // Validate inputs
        if (notificationDTO == null) {
            throw new CustomException("Notification data cannot be null");
        }

        if (tpdtos == null || tpdtos.isEmpty()) {
            throw new CustomException("Practical groups list cannot be null or empty");
        }

        // For now, this method is unimplemented
        throw new CustomException("Method not implemented yet: sendNotificationToTPs");
    }

    @Override
    public void sendNotificationToTP(NotificationDTO notificationDTO, TPDTO tpdto) throws CustomException {
        // Validate inputs
        if (notificationDTO == null) {
            throw new CustomException("Notification data cannot be null");
        }

        if (tpdto == null) {
            throw new CustomException("Practical group data cannot be null");
        }

        // For now, this method is unimplemented
        throw new CustomException("Method not implemented yet: sendNotificationToTP");
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SalleDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Salle;
import com.scheduling.universityschedule_backend.repository.SalleRepository;
import com.scheduling.universityschedule_backend.service.SalleService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for room management.
 * Handles room creation, updates, and availability checking.
 */
@Service
@Transactional
public class SalleServiceImpl implements SalleService {

    private final SalleRepository salleRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public SalleServiceImpl(SalleRepository salleRepository,
                            EntityMapper entityMapper) {
        this.salleRepository = salleRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public SalleDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Room ID cannot be null");
            }

            // Retrieve room
            Salle salle = salleRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Room not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toSalleDTO(salle);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve room with ID: " + id, e);
        }
    }

    @Override
    public List<SalleDTO> findAll() throws CustomException {
        try {
            // Retrieve all rooms
            List<Salle> salles = salleRepository.findAll();

            // Convert to DTOs
            return salles.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSalleDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all rooms", e);
        }
    }

    @Override
    public SalleDTO create(SalleDTO salleDTO) throws CustomException {
        try {
            // Validate input
            if (salleDTO == null) {
                throw new CustomException("Room data cannot be null");
            }

            // Check for duplicate ID if provided
            if (salleDTO.getId() != null && salleRepository.existsById(salleDTO.getId())) {
                throw new CustomException("Room with ID " + salleDTO.getId() + " already exists");
            }

            // Convert to entity
            Salle salle = entityMapper.toSalle(salleDTO);

            // Save entity
            Salle savedSalle = salleRepository.save(salle);

            // Convert back to DTO
            return entityMapper.toSalleDTO(savedSalle);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create room", e);
        }
    }

    @Override
    public SalleDTO update(Long id, SalleDTO salleDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Room ID cannot be null");
            }

            if (salleDTO == null) {
                throw new CustomException("Room data cannot be null");
            }

            // Find existing room
            Salle existingSalle = salleRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Room not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(salleDTO, existingSalle);

            // Save updated entity
            Salle updatedSalle = salleRepository.save(existingSalle);

            // Convert back to DTO
            return entityMapper.toSalleDTO(updatedSalle);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update room with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Room ID cannot be null");
            }

            // Check if room exists
            if (!salleRepository.existsById(id)) {
                throw new CustomException("Room not found with ID: " + id);
            }

            // Delete room
            salleRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete room with ID: " + id, e);
        }
    }

    @Override
    public List<SalleDTO> getAvailableRooms(LocalDate date, DayOfWeek day, LocalTime startTime, LocalTime endTime) throws CustomException {
        try {
            // Input validation
            if (day == null) {
                throw new CustomException("Day of week cannot be null");
            }
            if (startTime == null || endTime == null) {
                throw new CustomException("Start time and end time cannot be null");
            }
            if (startTime.isAfter(endTime) || startTime.equals(endTime)) {
                throw new CustomException("Start time must be before end time");
            }

            // For catch-up sessions (which require a specific date)
            // the date parameter is optional for regular sessions

            // Use the repository's custom query method that already handles the logic efficiently
            List<Salle> availableRooms = salleRepository.findAvailableRooms(day, startTime, endTime, date);

            // Transform to DTOs
            return availableRooms.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSalleDTO)
                    .collect(Collectors.toList());

        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (DateTimeParseException e) {
            throw new CustomException("Invalid date/time format: " + e.getMessage(), e);
        } catch (Exception e) {
            throw new CustomException("Failed to find available rooms: " + e.getMessage(), e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.SeanceConflictDTO;
import com.scheduling.universityschedule_backend.dto.SeanceRoomConflictDTO;
import com.scheduling.universityschedule_backend.dto.SingleSeanceConflictDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.model.FrequenceType;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.SeanceService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for session operations.
 * Handles session creation, scheduling, conflict detection, and related operations.
 */
@Service
@Transactional
public class SeanceServiceImpl implements SeanceService {

    /**
     * Frequency type constants
     */
    private static final FrequenceType BIWEEKLY = FrequenceType.BIWEEKLY;
    private static final FrequenceType CATCHUP = FrequenceType.CATCHUP;
    private static final FrequenceType WEEKLY = FrequenceType.WEEKLY;

    private final SeanceRepository seanceRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public SeanceServiceImpl(SeanceRepository seanceRepository,
                             EntityMapper entityMapper) {
        this.seanceRepository = seanceRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public SeanceDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Session ID cannot be null");
            }

            // Retrieve session
            Seance seance = seanceRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Session not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toSeanceDTO(seance);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve session with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceDTO> findAll() throws CustomException {
        try {
            // Retrieve all sessions
            List<Seance> seances = seanceRepository.findAll();

            // Convert to DTOs
            return seances.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all sessions", e);
        }
    }

    @Override
    public SeanceDTO create(SeanceDTO seanceDTO) throws CustomException {
        try {
            // Validate input
            if (seanceDTO == null) {
                throw new CustomException("Session data cannot be null");
            }

            // Note: We're allowing creation even with conflicts as per instructions

            // Convert DTO to entity
            Seance seance = entityMapper.toSeance(seanceDTO);

            // Save entity
            Seance savedSeance = seanceRepository.save(seance);

            // Convert back to DTO
            return entityMapper.toSeanceDTO(savedSeance);
        } catch (DateTimeParseException e) {
            throw new CustomException("Invalid date/time format: " + e.getMessage(), e);
        } catch (Exception e) {
            throw new CustomException("Failed to create session: " + e.getMessage(), e);
        }
    }

    @Override
    public SeanceDTO update(Long id, SeanceDTO seanceDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Session ID cannot be null");
            }

            if (seanceDTO == null) {
                throw new CustomException("Session data cannot be null");
            }

            // Find existing session
            Seance existingSeance = seanceRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Session not found with ID: " + id));

            // Note: We're allowing updates even with conflicts as per instructions

            // Set ID in DTO to ensure we're updating the right entity
            seanceDTO.setId(id);

            // Update entity
            entityMapper.updateFromDto(seanceDTO, existingSeance);

            // Save updated entity
            Seance updatedSeance = seanceRepository.save(existingSeance);

            // Convert back to DTO
            return entityMapper.toSeanceDTO(updatedSeance);
        } catch (CustomException e) {
            throw e;
        } catch (DateTimeParseException e) {
            throw new CustomException("Invalid date/time format: " + e.getMessage(), e);
        } catch (Exception e) {
            throw new CustomException("Failed to update session with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Session ID cannot be null");
            }

            // Check if session exists
            if (!seanceRepository.existsById(id)) {
                throw new CustomException("Session not found with ID: " + id);
            }

            // Delete session
            seanceRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete session with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceConflictDTO> getAllConflicts() throws CustomException {
        try {
            // Directly call repository method to find all conflicts
            List<Object[]> conflicts = seanceRepository.findConflictingSeancePairs(BIWEEKLY, CATCHUP);

            // Map conflicts to DTOs
            return entityMapper.toSeanceConflictDTOList(conflicts);
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all session conflicts", e);
        }
    }

    @Override
    public List<SeanceRoomConflictDTO> getRoomConflicts() throws CustomException {
        try {
            // Directly call repository method to find room conflicts
            List<Object[]> conflicts = seanceRepository.findConflictingByRooms(BIWEEKLY, CATCHUP);

            // Map conflicts to DTOs
            return entityMapper.toSeanceRoomConflictDTOList(conflicts);
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve room conflicts", e);
        }
    }

    @Override
    public List<SingleSeanceConflictDTO> getConflictsForSession(Long seanceId) throws CustomException {
        try {
            // Validate input
            if (seanceId == null) {
                throw new CustomException("Session ID cannot be null");
            }

            // Directly call repository method to find conflicts for specific session
            List<Object[]> conflicts = seanceRepository.findRoomConflictsForSeanceById(seanceId, BIWEEKLY, CATCHUP);

            // Map conflicts to DTOs
            return entityMapper.toSingleSeanceConflictDTOList(conflicts);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve conflicts for session with ID: " + seanceId, e);
        }
    }

    @Override
    public List<SingleSeanceConflictDTO> getConflictsForSession(SeanceDTO seanceDTO) throws CustomException {
        try {
            // Validate input
            if (seanceDTO == null) {
                throw new CustomException("Session data cannot be null");
            }

            // Parse time strings to LocalTime objects
            LocalTime startTime = null;
            LocalTime endTime = null;
            try {
                if (seanceDTO.getHeureDebut() != null) {
                    startTime = LocalTime.parse(seanceDTO.getHeureDebut());
                }
                if (seanceDTO.getHeureFin() != null) {
                    endTime = LocalTime.parse(seanceDTO.getHeureFin());
                }
            } catch (DateTimeParseException e) {
                throw new CustomException("Invalid time format: " + e.getMessage(), e);
            }

            // Parse day of week
            DayOfWeek dayOfWeek = null;
            if (seanceDTO.getJour() != null) {
                try {
                    dayOfWeek = DayOfWeek.valueOf(seanceDTO.getJour());
                } catch (IllegalArgumentException e) {
                    throw new CustomException("Invalid day of week: " + seanceDTO.getJour(), e);
                }
            }

            // Parse frequency type
            FrequenceType frequenceType =null ;
            if (seanceDTO.getFrequence() != null) {
                try {
                    frequenceType = FrequenceType.valueOf(seanceDTO.getFrequence());
                } catch (IllegalArgumentException e) {
                    throw new CustomException("Invalid frequency type: " + seanceDTO.getFrequence(), e);
                }
            } else {
                // Default to weekly if not specified
                frequenceType = WEEKLY;
            }

            // Parse date (optional, used for catch-up sessions)
            LocalDate date = null;
            if (seanceDTO.getDate() != null && !seanceDTO.getDate().isEmpty()) {
                try {
                    date = LocalDate.parse(seanceDTO.getDate());
                } catch (DateTimeParseException e) {
                    throw new CustomException("Invalid date format: " + e.getMessage(), e);
                }
            }

            // Directly call repository method to find conflicts
            List<Object[]> conflicts = seanceRepository.findConflictsForSeance(
                    seanceDTO.getSalleId(),
                    seanceDTO.getEnseignantId(),
                    seanceDTO.getTpIds(),
                    seanceDTO.getTdIds(),
                    seanceDTO.getBrancheIds(),
                    dayOfWeek,
                    startTime,
                    endTime,
                    frequenceType,
                    date,
                    BIWEEKLY,
                    CATCHUP
            );

            // Map conflicts to DTOs
            return entityMapper.toSingleSeanceConflictDTOList(conflicts);

        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to check for session conflicts: " + e.getMessage(), e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.TDDTO;
import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.model.TD;
import com.scheduling.universityschedule_backend.repository.TDRepository;
import com.scheduling.universityschedule_backend.service.TDService;
import com.scheduling.universityschedule_backend.util.CustomLogger;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Service implementation for managing Tutorial Groups (TD).
 * Handles CRUD operations and related functionalities for TDs.
 */
@Service
@Transactional
public class TDServiceImpl implements TDService {

    private final TDRepository tdRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     *
     * @param tdRepository The repository for TD entities
     * @param entityMapper The mapper for converting between entities and DTOs
     */
    public TDServiceImpl(TDRepository tdRepository, EntityMapper entityMapper) {
        this.tdRepository = tdRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    @Transactional(readOnly = true)
    public List<TDDTO> findAll() throws CustomException {
        try {
            CustomLogger.logInfo("Fetching all tutorial groups");
            List<TD> tds = tdRepository.findAll();

            return tds.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toTDDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve all tutorial groups", e);
            throw new CustomException("Failed to retrieve all tutorial groups", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public TDDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching tutorial group with ID: " + id);
            TD td = tdRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Tutorial group not found with ID: " + id);
                        return new CustomException("Tutorial group not found with ID: " + id);
                    });

            return entityMapper.toTDDTO(td);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve tutorial group with ID: " + id, e);
            throw new CustomException("Failed to retrieve tutorial group with ID: " + id, e);
        }
    }

    @Override
    public TDDTO create(TDDTO tdDTO) throws CustomException {
        try {
            // Validate input
            if (tdDTO == null) {
                CustomLogger.logError("Tutorial group data cannot be null");
                throw new CustomException("Tutorial group data cannot be null");
            }

            // Check for duplicate ID if provided
            if (tdDTO.getId() != null && tdRepository.existsById(tdDTO.getId())) {
                CustomLogger.logError("Tutorial group with ID " + tdDTO.getId() + " already exists");
                throw new CustomException("Tutorial group with ID " + tdDTO.getId() + " already exists");
            }

            CustomLogger.logInfo("Creating new tutorial group");
            TD td = entityMapper.toTD(tdDTO);
            TD savedTD = tdRepository.save(td);

            CustomLogger.logInfo("Created tutorial group with ID: " + savedTD.getId());
            return entityMapper.toTDDTO(savedTD);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to create tutorial group", e);
            throw new CustomException("Failed to create tutorial group", e);
        }
    }

    @Override
    public TDDTO update(Long id, TDDTO tdDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            if (tdDTO == null) {
                CustomLogger.logError("Tutorial group data cannot be null");
                throw new CustomException("Tutorial group data cannot be null");
            }

            CustomLogger.logInfo("Updating tutorial group with ID: " + id);
            TD existingTD = tdRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Tutorial group not found with ID: " + id);
                        return new CustomException("Tutorial group not found with ID: " + id);
                    });

            // Set the ID in the DTO to ensure we're updating the correct entity
            tdDTO.setId(id);
            entityMapper.updateFromDto(tdDTO, existingTD);
            TD updatedTD = tdRepository.save(existingTD);

            CustomLogger.logInfo("Updated tutorial group with ID: " + id);
            return entityMapper.toTDDTO(updatedTD);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to update tutorial group with ID: " + id, e);
            throw new CustomException("Failed to update tutorial group with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Checking if tutorial group with ID: " + id + " exists");
            if (!tdRepository.existsById(id)) {
                CustomLogger.logError("Tutorial group not found with ID: " + id);
                throw new CustomException("Tutorial group not found with ID: " + id);
            }

            CustomLogger.logInfo("Deleting tutorial group with ID: " + id);
            tdRepository.deleteById(id);
            CustomLogger.logInfo("Deleted tutorial group with ID: " + id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to delete tutorial group with ID: " + id, e);
            throw new CustomException("Failed to delete tutorial group with ID: " + id, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<TPDTO> getTPs(Long tdId) throws CustomException {
        try {
            // Validate input
            if (tdId == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching practical groups for tutorial group with ID: " + tdId);
            TD td = tdRepository.findById(tdId)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Tutorial group not found with ID: " + tdId);
                        return new CustomException("Tutorial group not found with ID: " + tdId);
                    });

            // Safely handle potential null collection
            if (td.getTpList() == null) {
                CustomLogger.logInfo("No practical groups found for tutorial group with ID: " + tdId);
                return Collections.emptyList();
            }

            List<TPDTO> tpDTOs = td.getTpList().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toTPDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Found " + tpDTOs.size() + " practical groups for tutorial group with ID: " + tdId);
            return tpDTOs;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve practical groups for tutorial group with ID: " + tdId, e);
            throw new CustomException("Failed to retrieve practical groups for tutorial group with ID: " + tdId, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<SeanceDTO> generateSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Generating schedule for tutorial group with ID: " + id);
            TD td = tdRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Tutorial group not found with ID: " + id);
                        return new CustomException("Tutorial group not found with ID: " + id);
                    });

            // Safely handle potential null collection
            if (td.getSeances() == null) {
                CustomLogger.logInfo("No sessions found for tutorial group with ID: " + id);
                return Collections.emptyList();
            }

            List<SeanceDTO> sessionDTOs = td.getSeances().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Generated schedule with " + sessionDTOs.size() + " sessions for tutorial group with ID: " + id);
            return sessionDTOs;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to generate schedule for tutorial group with ID: " + id, e);
            throw new CustomException("Failed to generate schedule for tutorial group with ID: " + id, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<EtudiantDTO> getEtudiants(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Tutorial group ID cannot be null");
                throw new CustomException("Tutorial group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching students for tutorial group with ID: " + id);
            List<EtudiantDTO> students;

            // Check if there's a custom repository method for this query
            try {
                // This uses the repository's custom method
                CustomLogger.logInfo("Using repository method to fetch students directly");
                students = tdRepository.findAllEtudiantsByTdId(id).stream()
                        .filter(Objects::nonNull)
                        .map(entityMapper::toEtudiantDTO)
                        .collect(Collectors.toList());
            } catch (Exception ex) {
                // Fallback to relationship navigation if custom method isn't available
                CustomLogger.logInfo("Falling back to relationship navigation to get students");
                TD td = tdRepository.findById(id)
                        .orElseThrow(() -> {
                            CustomLogger.logError("Tutorial group not found with ID: " + id);
                            return new CustomException("Tutorial group not found with ID: " + id);
                        });

                // Safely handle potential null collection
                if (td.getTpList() == null) {
                    CustomLogger.logInfo("No practical groups found for tutorial group with ID: " + id);
                    return Collections.emptyList();
                }

                students = td.getTpList().stream()
                        .filter(Objects::nonNull)
                        .flatMap(tp -> {
                            if (tp.getEtudiants() == null) {
                                return Stream.<Etudiant>empty();
                            }
                            return tp.getEtudiants().stream();
                        })
                        .filter(Objects::nonNull)
                        .map(entityMapper::toEtudiantDTO)
                        .collect(Collectors.toList());
            }

            CustomLogger.logInfo("Found " + students.size() + " students for tutorial group with ID: " + id);
            return students;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve students for tutorial group with ID: " + id, e);
            throw new CustomException("Failed to retrieve students for tutorial group with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.TP;
import com.scheduling.universityschedule_backend.repository.TPRepository;
import com.scheduling.universityschedule_backend.service.TPService;
import com.scheduling.universityschedule_backend.util.CustomLogger;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for managing Practical Groups (TP).
 * Handles CRUD operations and related functionalities for TPs.
 *
 * @author Mahmoud-ABK
 * @version 1.0
 * @since 2025-03-05
 */
@Service
@Transactional
public class TPServiceImpl implements TPService {

    private final TPRepository tpRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     *
     * @param tpRepository The repository for TP entities
     * @param entityMapper The mapper for converting between entities and DTOs
     */
    public TPServiceImpl(TPRepository tpRepository, EntityMapper entityMapper) {
        this.tpRepository = tpRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    @Transactional(readOnly = true)
    public List<TPDTO> findAll() throws CustomException {
        try {
            CustomLogger.logInfo("Fetching all practical groups");
            List<TP> tps = tpRepository.findAll();

            List<TPDTO> tpDTOs = tps.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toTPDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Found " + tpDTOs.size() + " practical groups");
            return tpDTOs;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve all practical groups", e);
            throw new CustomException("Failed to retrieve all practical groups", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public TPDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching practical group with ID: " + id);
            TP tp = tpRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Practical group not found with ID: " + id);
                        return new CustomException("Practical group not found with ID: " + id);
                    });

            return entityMapper.toTPDTO(tp);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve practical group with ID: " + id, e);
            throw new CustomException("Failed to retrieve practical group with ID: " + id, e);
        }
    }

    @Override
    public TPDTO create(TPDTO tpDTO) throws CustomException {
        try {
            // Validate input
            if (tpDTO == null) {
                CustomLogger.logError("Practical group data cannot be null");
                throw new CustomException("Practical group data cannot be null");
            }

            // Check for duplicate ID if provided
            if (tpDTO.getId() != null && tpRepository.existsById(tpDTO.getId())) {
                CustomLogger.logError("Practical group with ID " + tpDTO.getId() + " already exists");
                throw new CustomException("Practical group with ID " + tpDTO.getId() + " already exists");
            }

            CustomLogger.logInfo("Creating new practical group");
            TP tp = entityMapper.toTP(tpDTO);
            TP savedTP = tpRepository.save(tp);

            CustomLogger.logInfo("Created practical group with ID: " + savedTP.getId());
            return entityMapper.toTPDTO(savedTP);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to create practical group", e);
            throw new CustomException("Failed to create practical group", e);
        }
    }

    @Override
    public TPDTO update(Long id, TPDTO tpDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            if (tpDTO == null) {
                CustomLogger.logError("Practical group data cannot be null");
                throw new CustomException("Practical group data cannot be null");
            }

            CustomLogger.logInfo("Updating practical group with ID: " + id);
            TP existingTP = tpRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Practical group not found with ID: " + id);
                        return new CustomException("Practical group not found with ID: " + id);
                    });

            // Set the ID in the DTO to ensure we're updating the correct entity
            tpDTO.setId(id);
            entityMapper.updateFromDto(tpDTO, existingTP);
            TP updatedTP = tpRepository.save(existingTP);

            CustomLogger.logInfo("Updated practical group with ID: " + id);
            return entityMapper.toTPDTO(updatedTP);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to update practical group with ID: " + id, e);
            throw new CustomException("Failed to update practical group with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            CustomLogger.logInfo("Checking if practical group with ID: " + id + " exists");
            if (!tpRepository.existsById(id)) {
                CustomLogger.logError("Practical group not found with ID: " + id);
                throw new CustomException("Practical group not found with ID: " + id);
            }

            CustomLogger.logInfo("Deleting practical group with ID: " + id);
            tpRepository.deleteById(id);
            CustomLogger.logInfo("Deleted practical group with ID: " + id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to delete practical group with ID: " + id, e);
            throw new CustomException("Failed to delete practical group with ID: " + id, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<EtudiantDTO> getStudents(Long tpId) throws CustomException {
        CustomLogger.logInfo("Redirecting getStudents to getEtudiants method for practical group: " + tpId);
        return getEtudiants(tpId);
    }

    @Override
    @Transactional(readOnly = true)
    public List<SeanceDTO> generateSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            CustomLogger.logInfo("Generating schedule for practical group with ID: " + id);
            TP tp = tpRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Practical group not found with ID: " + id);
                        return new CustomException("Practical group not found with ID: " + id);
                    });

            // Safely handle potential null collection
            if (tp.getSeances() == null) {
                CustomLogger.logInfo("No sessions found for practical group with ID: " + id);
                return Collections.emptyList();
            }

            List<SeanceDTO> sessionDTOs = tp.getSeances().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Generated schedule with " + sessionDTOs.size() + " sessions for practical group with ID: " + id);
            return sessionDTOs;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to generate schedule for practical group with ID: " + id, e);
            throw new CustomException("Failed to generate schedule for practical group with ID: " + id, e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<EtudiantDTO> getEtudiants(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                CustomLogger.logError("Practical group ID cannot be null");
                throw new CustomException("Practical group ID cannot be null");
            }

            CustomLogger.logInfo("Fetching students for practical group with ID: " + id);
            TP tp = tpRepository.findById(id)
                    .orElseThrow(() -> {
                        CustomLogger.logError("Practical group not found with ID: " + id);
                        return new CustomException("Practical group not found with ID: " + id);
                    });

            // Safely handle potential null collection
            if (tp.getEtudiants() == null) {
                CustomLogger.logInfo("No students found for practical group with ID: " + id);
                return Collections.emptyList();
            }

            List<EtudiantDTO> students = tp.getEtudiants().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toEtudiantDTO)
                    .collect(Collectors.toList());

            CustomLogger.logInfo("Found " + students.size() + " students for practical group with ID: " + id);
            return students;
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            CustomLogger.logError("Failed to retrieve students for practical group with ID: " + id, e);
            throw new CustomException("Failed to retrieve students for practical group with ID: " + id, e);
        }
    }
}