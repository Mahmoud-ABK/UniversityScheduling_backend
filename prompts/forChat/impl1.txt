package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.AdministrateurDTO;
import com.scheduling.universityschedule_backend.dto.PropositionDeRattrapageDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Administrateur;
import com.scheduling.universityschedule_backend.model.PropositionDeRattrapage;
import com.scheduling.universityschedule_backend.repository.AdministrateurRepository;
import com.scheduling.universityschedule_backend.repository.PropositionDeRattrapageRepository;
import com.scheduling.universityschedule_backend.service.AdministrateurService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;


import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service implementation for administrator operations.
 * Handles schedule management, makeup sessions, and system-wide notifications.
 */
@Service
@Transactional
public class AdministrateurServiceImpl implements AdministrateurService {

    /**
     * Status constants for makeup session proposals
     */
    private static final String STATUS_APPROVED = "approved";
    private static final String STATUS_REJECTED = "rejected";

    private final AdministrateurRepository administrateurRepository;
    private final PropositionDeRattrapageRepository propositionDeRattrapageRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public AdministrateurServiceImpl(AdministrateurRepository administrateurRepository,
                                     PropositionDeRattrapageRepository propositionDeRattrapageRepository,
                                     EntityMapper entityMapper) {
        this.administrateurRepository = administrateurRepository;
        this.propositionDeRattrapageRepository = propositionDeRattrapageRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public AdministrateurDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Administrator ID cannot be null");
            }

            // Retrieve administrator
            Administrateur administrateur = administrateurRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Administrator not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toAdministrateurDTO(administrateur);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve administrator with ID: " + id, e);
        }
    }

    @Override
    public List<AdministrateurDTO> findAll() throws CustomException {
        try {
            // Retrieve all administrators
            List<Administrateur> administrateurs = administrateurRepository.findAll();

            // Handle empty list case
            if (administrateurs.isEmpty()) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return administrateurs.stream()
                    .map(entityMapper::toAdministrateurDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all administrators", e);
        }
    }

    @Override
    public AdministrateurDTO create(AdministrateurDTO administrateurDTO) throws CustomException {
        try {
            // Validate input
            if (administrateurDTO == null) {
                throw new CustomException("Administrator data cannot be null");
            }

            // Check for duplicate ID if provided
            if (administrateurDTO.getId() != null && administrateurRepository.existsById(administrateurDTO.getId())) {
                throw new CustomException("Administrator with ID " + administrateurDTO.getId() + " already exists");
            }

            // Convert to entity
            Administrateur administrateur = entityMapper.toAdministrateur(administrateurDTO);

            // Save entity
            Administrateur savedAdministrateur = administrateurRepository.save(administrateur);

            // Convert back to DTO
            return entityMapper.toAdministrateurDTO(savedAdministrateur);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create administrator", e);
        }
    }

    @Override
    public AdministrateurDTO update(Long id, AdministrateurDTO administrateurDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Administrator ID cannot be null");
            }

            if (administrateurDTO == null) {
                throw new CustomException("Administrator data cannot be null");
            }

            // Find existing administrator
            Administrateur existingAdministrateur = administrateurRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Administrator not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(administrateurDTO, existingAdministrateur);

            // Save updated entity
            Administrateur updatedAdministrateur = administrateurRepository.save(existingAdministrateur);

            // Convert back to DTO
            return entityMapper.toAdministrateurDTO(updatedAdministrateur);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update administrator with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Administrator ID cannot be null");
            }

            // Check if administrator exists
            if (!administrateurRepository.existsById(id)) {
                throw new CustomException("Administrator not found with ID: " + id);
            }

            // Delete administrator
            administrateurRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete administrator with ID: " + id, e);
        }
    }

    @Override
    public List<PropositionDeRattrapageDTO> getAllMakeupSessions() throws CustomException {
        try {
            // Retrieve all makeup session proposals
            List<PropositionDeRattrapage> propositions = propositionDeRattrapageRepository.findAll();

            // Handle empty list case
            if (propositions.isEmpty()) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return propositions.stream()
                    .map(entityMapper::toPropositionDeRattrapageDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve makeup session proposals", e);
        }
    }

    @Override
    public void approveMakeupSession(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Makeup session proposal ID cannot be null");
            }

            // Find existing makeup session proposal
            PropositionDeRattrapage proposition = propositionDeRattrapageRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Makeup session proposal not found with ID: " + id));

            // Validate current status
            String currentStatus = proposition.getStatus();
            if (STATUS_APPROVED.equals(currentStatus)) {
                // Already approved, no need to update
                return;
            }

            if (STATUS_REJECTED.equals(currentStatus)) {
                throw new CustomException("Cannot approve: makeup session proposal already rejected");
            }

            // Update status to approved
            proposition.setStatus(STATUS_APPROVED);

            // Save updated entity
            propositionDeRattrapageRepository.save(proposition);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to approve makeup session proposal with ID: " + id, e);
        }
    }

    @Override
    public void rejectMakeupSession(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Makeup session proposal ID cannot be null");
            }

            // Find existing makeup session proposal
            PropositionDeRattrapage proposition = propositionDeRattrapageRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Makeup session proposal not found with ID: " + id));

            // Validate current status
            String currentStatus = proposition.getStatus();
            if (STATUS_REJECTED.equals(currentStatus)) {
                // Already rejected, no need to update
                return;
            }

            if (STATUS_APPROVED.equals(currentStatus)) {
                throw new CustomException("Cannot reject: makeup session proposal already approved");
            }

            // Update status to rejected
            proposition.setStatus(STATUS_REJECTED);

            // Save updated entity
            propositionDeRattrapageRepository.save(proposition);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to reject makeup session proposal with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.BrancheDTO;
import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Branche;
import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.repository.BrancheRepository;
import com.scheduling.universityschedule_backend.repository.TDRepository;
import com.scheduling.universityschedule_backend.service.BrancheService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for branch management.
 * Handles CRUD operations and branch-related functionalities.
 */
@Service
@Transactional
public class BrancheServiceImpl implements BrancheService {

    private final BrancheRepository brancheRepository;
    private final TDRepository tdRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public BrancheServiceImpl(BrancheRepository brancheRepository,
                              TDRepository tdRepository,
                              EntityMapper entityMapper) {
        this.brancheRepository = brancheRepository;
        this.tdRepository = tdRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public BrancheDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            // Retrieve branch
            Branche branche = brancheRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Branch not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toBrancheDTO(branche);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve branch with ID: " + id, e);
        }
    }

    @Override
    public List<BrancheDTO> findAll() throws CustomException {
        try {
            // Retrieve all branches
            List<Branche> branches = brancheRepository.findAll();

            // Convert to DTOs (no need to check if list is null - JPA returns empty list)
            return branches.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toBrancheDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all branches", e);
        }
    }

    @Override
    public BrancheDTO create(BrancheDTO brancheDTO) throws CustomException {
        try {
            // Validate input
            if (brancheDTO == null) {
                throw new CustomException("Branch data cannot be null");
            }

            // Check for duplicate ID if provided
            if (brancheDTO.getId() != null && brancheRepository.existsById(brancheDTO.getId())) {
                throw new CustomException("Branch with ID " + brancheDTO.getId() + " already exists");
            }

            // Convert to entity
            Branche branche = entityMapper.toBranche(brancheDTO);

            // Save entity
            Branche savedBranche = brancheRepository.save(branche);

            // Convert back to DTO
            return entityMapper.toBrancheDTO(savedBranche);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create branch", e);
        }
    }

    @Override
    public BrancheDTO update(Long id, BrancheDTO brancheDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            if (brancheDTO == null) {
                throw new CustomException("Branch data cannot be null");
            }

            // Find existing branch
            Branche existingBranche = brancheRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Branch not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(brancheDTO, existingBranche);

            // Save updated entity
            Branche updatedBranche = brancheRepository.save(existingBranche);

            // Convert back to DTO
            return entityMapper.toBrancheDTO(updatedBranche);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update branch with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            // Check if branch exists
            if (!brancheRepository.existsById(id)) {
                throw new CustomException("Branch not found with ID: " + id);
            }

            // Delete branch
            brancheRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete branch with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceDTO> getSchedule(Long branchId) throws CustomException {
        try {
            // Validate input
            if (branchId == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            // Find branch
            Branche branche = brancheRepository.findById(branchId)
                    .orElseThrow(() -> new CustomException("Branch not found with ID: " + branchId));

            // Get sessions from branch - handle null case properly
            List<Seance> seances = branche.getSeances();
            if (seances == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return seances.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve schedule for branch with ID: " + branchId, e);
        }
    }

    @Override
    public List<EtudiantDTO> getEtudiants(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Branch ID cannot be null");
            }

            // Check if branch exists
            if (!brancheRepository.existsById(id)) {
                throw new CustomException("Branch not found with ID: " + id);
            }

            // Get students using TD repository
            List<Etudiant> etudiants = tdRepository.findAllEtudiantsByBrancheId(id);

            // JPA repositories typically return empty lists rather than null,
            // but we'll be defensive just in case
            if (etudiants == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return etudiants.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toEtudiantDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve students for branch with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.EnseignantDTO;
import com.scheduling.universityschedule_backend.dto.PropositionDeRattrapageDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.dto.SignalDTO;
import com.scheduling.universityschedule_backend.dto.TPDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Enseignant;
import com.scheduling.universityschedule_backend.repository.EnseignantRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.EnseignantService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for teacher operations.
 * Manages teacher schedules, teaching hours, and communication.
 */
@Service
@Transactional
public class EnseignantServiceImpl implements EnseignantService {

    private final EnseignantRepository enseignantRepository;
    private final SeanceRepository seanceRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public EnseignantServiceImpl(EnseignantRepository enseignantRepository,
                                 SeanceRepository seanceRepository,
                                 EntityMapper entityMapper) {
        this.enseignantRepository = enseignantRepository;
        this.seanceRepository = seanceRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public EnseignantDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Retrieve teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toEnseignantDTO(enseignant);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve teacher with ID: " + id, e);
        }
    }

    @Override
    public List<EnseignantDTO> findAll() throws CustomException {
        try {
            // Retrieve all teachers
            List<Enseignant> enseignants = enseignantRepository.findAll();

            // Convert to DTOs
            return enseignants.stream()
                    .map(entityMapper::toEnseignantDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all teachers", e);
        }
    }

    @Override
    public EnseignantDTO create(EnseignantDTO enseignantDTO) throws CustomException {
        try {
            // Validate input
            if (enseignantDTO == null) {
                throw new CustomException("Teacher data cannot be null");
            }

            // Check for duplicate ID if provided
            if (enseignantDTO.getId() != null && enseignantRepository.existsById(enseignantDTO.getId())) {
                throw new CustomException("Teacher with ID " + enseignantDTO.getId() + " already exists");
            }

            // Convert to entity
            Enseignant enseignant = entityMapper.toEnseignant(enseignantDTO);

            // Save entity
            Enseignant savedEnseignant = enseignantRepository.save(enseignant);

            // Convert back to DTO
            return entityMapper.toEnseignantDTO(savedEnseignant);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create teacher", e);
        }
    }

    @Override
    public EnseignantDTO update(Long id, EnseignantDTO enseignantDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            if (enseignantDTO == null) {
                throw new CustomException("Teacher data cannot be null");
            }

            // Find existing teacher
            Enseignant existingEnseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(enseignantDTO, existingEnseignant);

            // Save updated entity
            Enseignant updatedEnseignant = enseignantRepository.save(existingEnseignant);

            // Convert back to DTO
            return entityMapper.toEnseignantDTO(updatedEnseignant);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update teacher with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Check if teacher exists
            if (!enseignantRepository.existsById(id)) {
                throw new CustomException("Teacher not found with ID: " + id);
            }

            // Delete teacher
            enseignantRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete teacher with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceDTO> getSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Find teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Get sessions from teacher - using safe access pattern for collections
            if (enseignant.getSeances() == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return enseignant.getSeances().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve schedule for teacher with ID: " + id, e);
        }
    }

    @Override
    public int getTotalTeachingHours(Long teacherId, LocalDate startDate, LocalDate endDate) throws CustomException {
        // For now, we're leaving this unimplemented
        throw new CustomException("Method not implemented yet: getTotalTeachingHours");
    }

    @Override
    public PropositionDeRattrapageDTO submitMakeupRequest(Long id, PropositionDeRattrapageDTO proposition) throws CustomException {
        // For now, we're leaving this unimplemented
        throw new CustomException("Method not implemented yet: submitMakeupRequest");
    }

    @Override
    public SignalDTO submitSignal(Long id, SignalDTO signal) throws CustomException {
        // For now, we're leaving this unimplemented
        throw new CustomException("Method not implemented yet: submitSignal");
    }

    @Override
    public List<SignalDTO> getSignals(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Teacher ID cannot be null");
            }

            // Find teacher
            Enseignant enseignant = enseignantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Teacher not found with ID: " + id));

            // Get signals from teacher - using safe access pattern for collections
            if (enseignant.getSignals() == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return enseignant.getSignals().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSignalDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve signals for teacher with ID: " + id, e);
        }
    }

    @Override
    public List<String> getSubjects(Long id) throws CustomException {
        // For now, we're leaving this unimplemented
        throw new CustomException("Method not implemented yet: getSubjects");
    }

    @Override
    public List<TPDTO> getStudentGroups(Long id) throws CustomException {
        // For now, we're leaving this unimplemented
        throw new CustomException("Method not implemented yet: getStudentGroups");
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.EtudiantDTO;
import com.scheduling.universityschedule_backend.dto.NotificationDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.Etudiant;
import com.scheduling.universityschedule_backend.repository.EtudiantRepository;
import com.scheduling.universityschedule_backend.repository.NotificationRepository;
import com.scheduling.universityschedule_backend.service.EtudiantService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for student operations.
 * Handles CRUD operations and student-related functionalities.
 */
@Service
@Transactional
public class EtudiantServiceImpl implements EtudiantService {

    private final EtudiantRepository etudiantRepository;
    private final NotificationRepository notificationRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public EtudiantServiceImpl(EtudiantRepository etudiantRepository,
                               NotificationRepository notificationRepository,
                               EntityMapper entityMapper) {
        this.etudiantRepository = etudiantRepository;
        this.notificationRepository = notificationRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public EtudiantDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Retrieve student
            Etudiant etudiant = etudiantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Student not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toEtudiantDTO(etudiant);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve student with ID: " + id, e);
        }
    }

    @Override
    public List<EtudiantDTO> findAll() throws CustomException {
        try {
            // Retrieve all students
            List<Etudiant> etudiants = etudiantRepository.findAll();

            // Convert to DTOs (JPA repositories typically return empty lists rather than null)
            return etudiants.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toEtudiantDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all students", e);
        }
    }

    @Override
    public EtudiantDTO create(EtudiantDTO etudiantDTO) throws CustomException {
        try {
            // Validate input
            if (etudiantDTO == null) {
                throw new CustomException("Student data cannot be null");
            }

            // Check for duplicate ID if provided
            if (etudiantDTO.getId() != null && etudiantRepository.existsById(etudiantDTO.getId())) {
                throw new CustomException("Student with ID " + etudiantDTO.getId() + " already exists");
            }

            // Convert to entity
            Etudiant etudiant = entityMapper.toEtudiant(etudiantDTO);

            // Save entity
            Etudiant savedEtudiant = etudiantRepository.save(etudiant);

            // Convert back to DTO
            return entityMapper.toEtudiantDTO(savedEtudiant);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create student", e);
        }
    }

    @Override
    public EtudiantDTO update(Long id, EtudiantDTO etudiantDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            if (etudiantDTO == null) {
                throw new CustomException("Student data cannot be null");
            }

            // Find existing student
            Etudiant existingEtudiant = etudiantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Student not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(etudiantDTO, existingEtudiant);

            // Save updated entity
            Etudiant updatedEtudiant = etudiantRepository.save(existingEtudiant);

            // Convert back to DTO
            return entityMapper.toEtudiantDTO(updatedEtudiant);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update student with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Check if student exists
            if (!etudiantRepository.existsById(id)) {
                throw new CustomException("Student not found with ID: " + id);
            }

            // Delete student
            etudiantRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete student with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceDTO> getPersonalSchedule(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Find student
            Etudiant etudiant = etudiantRepository.findById(id)
                    .orElseThrow(() -> new CustomException("Student not found with ID: " + id));

            // Check if student is assigned to a practical group
            if (etudiant.getTp() == null) {
                throw new CustomException("Student with ID: " + id + " is not assigned to any practical group (TP)");
            }

            // Get sessions from TP
            if (etudiant.getTp().getSeances() == null) {
                return Collections.emptyList();
            }

            // Convert to DTOs
            return etudiant.getTp().getSeances().stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeanceDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve personal schedule for student with ID: " + id, e);
        }
    }

    @Override
    public List<SeanceDTO> getTDSchedule(Long id) throws CustomException {
        // This method is unimplemented for now
        throw new CustomException("Method not implemented yet: getBranchSchedule");
    }
    @Override
    public List<SeanceDTO> getBranchSchedule(Long id) throws CustomException {
        // This method is unimplemented for now
        throw new CustomException("Method not implemented yet: getBranchSchedule");
    }

    @Override
    public List<NotificationDTO> getNotifications(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("Student ID cannot be null");
            }

            // Check if student exists
            if (!etudiantRepository.existsById(id)) {
                throw new CustomException("Student not found with ID: " + id);
            }

            // Get notifications for student

            return notificationRepository.findAllByPersonneId(id).stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toNotificationDTO)
                    .collect(Collectors.toList());
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve notifications for student with ID: " + id, e);
        }
    }
}package com.scheduling.universityschedule_backend.service.impl;

import com.scheduling.universityschedule_backend.dto.FichierExcelDTO;
import com.scheduling.universityschedule_backend.dto.SeanceDTO;
import com.scheduling.universityschedule_backend.exception.CustomException;
import com.scheduling.universityschedule_backend.mapper.EntityMapper;
import com.scheduling.universityschedule_backend.model.FichierExcel;
import com.scheduling.universityschedule_backend.model.Seance;
import com.scheduling.universityschedule_backend.repository.FichierExcelRepository;
import com.scheduling.universityschedule_backend.repository.SeanceRepository;
import com.scheduling.universityschedule_backend.service.ExcelFileService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Service implementation for Excel file operations.
 * Handles file uploads, processing, and history tracking.
 */
@Service
@Transactional
public class ExcelFileServiceImpl implements ExcelFileService {

    /**
     * File status constants
     */
    private static final String STATUS_PROCESSING = "Processing";
    private static final String STATUS_COMPLETED = "Completed";
    private static final String STATUS_FAILED = "Failed";

    private final FichierExcelRepository fichierExcelRepository;
    private final SeanceRepository seanceRepository;
    private final EntityMapper entityMapper;

    /**
     * Constructor injection for dependencies
     */
    public ExcelFileServiceImpl(FichierExcelRepository fichierExcelRepository,
                                SeanceRepository seanceRepository,
                                EntityMapper entityMapper) {
        this.fichierExcelRepository = fichierExcelRepository;
        this.seanceRepository = seanceRepository;
        this.entityMapper = entityMapper;
    }

    @Override
    public FichierExcelDTO findById(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("File ID cannot be null");
            }

            // Retrieve file
            FichierExcel fichierExcel = fichierExcelRepository.findById(id)
                    .orElseThrow(() -> new CustomException("File not found with ID: " + id));

            // Convert to DTO
            return entityMapper.toFichierExcelDTO(fichierExcel);
        } catch (CustomException e) {
            throw e; // Rethrow custom exceptions as-is
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve file with ID: " + id, e);
        }
    }

    @Override
    public List<FichierExcelDTO> findAll() throws CustomException {
        try {
            // Retrieve all files
            List<FichierExcel> fichiersExcel = fichierExcelRepository.findAll();

            // Convert to DTOs (JPA repositories typically return empty lists rather than null)
            return fichiersExcel.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toFichierExcelDTO)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new CustomException("Failed to retrieve all files", e);
        }
    }

    @Override
    public FichierExcelDTO create(FichierExcelDTO fichierExcelDTO) throws CustomException {
        try {
            // Validate input
            if (fichierExcelDTO == null) {
                throw new CustomException("File data cannot be null");
            }

            // Check for duplicate ID if provided
            if (fichierExcelDTO.getId() != null && fichierExcelRepository.existsById(fichierExcelDTO.getId())) {
                throw new CustomException("File with ID " + fichierExcelDTO.getId() + " already exists");
            }

            // Convert to entity
            FichierExcel fichierExcel = entityMapper.toFichierExcel(fichierExcelDTO);

            // Save entity
            FichierExcel savedFichierExcel = fichierExcelRepository.save(fichierExcel);

            // Convert back to DTO
            return entityMapper.toFichierExcelDTO(savedFichierExcel);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to create file", e);
        }
    }

    @Override
    public FichierExcelDTO update(Long id, FichierExcelDTO fichierExcelDTO) throws CustomException {
        try {
            // Validate inputs
            if (id == null) {
                throw new CustomException("File ID cannot be null");
            }

            if (fichierExcelDTO == null) {
                throw new CustomException("File data cannot be null");
            }

            // Find existing file
            FichierExcel existingFichierExcel = fichierExcelRepository.findById(id)
                    .orElseThrow(() -> new CustomException("File not found with ID: " + id));

            // Update entity with DTO data
            entityMapper.updateFromDto(fichierExcelDTO, existingFichierExcel);

            // Save updated entity
            FichierExcel updatedFichierExcel = fichierExcelRepository.save(existingFichierExcel);

            // Convert back to DTO
            return entityMapper.toFichierExcelDTO(updatedFichierExcel);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to update file with ID: " + id, e);
        }
    }

    @Override
    public void delete(Long id) throws CustomException {
        try {
            // Validate input
            if (id == null) {
                throw new CustomException("File ID cannot be null");
            }

            // Check if file exists
            if (!fichierExcelRepository.existsById(id)) {
                throw new CustomException("File not found with ID: " + id);
            }

            // Delete file
            fichierExcelRepository.deleteById(id);
        } catch (CustomException e) {
            throw e;
        } catch (Exception e) {
            throw new CustomException("Failed to delete file with ID: " + id, e);
        }
    }

    @Override
    public void upload(FichierExcelDTO file, List<SeanceDTO> seanceDTOS) throws CustomException {
        FichierExcel fichierExcel = null;

        try {
            // Validate inputs
            if (file == null) {
                throw new CustomException("File data cannot be null");
            }

            if (seanceDTOS == null) {
                throw new CustomException("Sessions data cannot be null");
            }

            // Convert file to entity
            fichierExcel = entityMapper.toFichierExcel(file);

            // Set import date and initial status
            fichierExcel.setImportDate(LocalDateTime.now());
            fichierExcel.setStatus(STATUS_PROCESSING);

            // Save file with initial status
            fichierExcelRepository.save(fichierExcel);

            // Convert and save sessions
            List<Seance> seances = seanceDTOS.stream()
                    .filter(Objects::nonNull)
                    .map(entityMapper::toSeance)
                    .collect(Collectors.toList());

            seanceRepository.saveAll(seances);

            // Update file status to completed
            fichierExcel.setStatus(STATUS_COMPLETED);
            fichierExcelRepository.save(fichierExcel);
        } catch (Exception e) {
            // Update file status to failed if an error occurs
            if (fichierExcel != null) {
                try {
                    fichierExcel.setStatus(STATUS_FAILED);
                    fichierExcelRepository.save(fichierExcel);
                } catch (Exception saveException) {
                    // Log this exception but don't throw it, we want to throw the original exception
                    System.err.println("Failed to update file status to FAILED: " + saveException.getMessage());
                }
            }

            // Throw the original exception
            if (e instanceof CustomException) {
                throw (CustomException) e;
            } else {
                throw new CustomException("Failed to upload and process file", e);
            }
        }
    }

    @Override
    public List<FichierExcelDTO> getImportHistory() throws CustomException {
        try {
            // Reuse findAll method since they do the same thing
            return findAll();
        } catch (CustomException e) {
            // Just change the error message to be more specific to this operation
            throw new CustomException("Failed to retrieve import history", e.getCause());
        }
    }
}